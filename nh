#!/usr/bin/env bash

set -e

DEFAULT_GHC=841  ## The value is actually configured, so this is for the absolute defaults.
DEFAULT_GHC_CONFIG=configuration-ghc-8.4.x.nix
ACME_ATTRIBUTE=nh-acme-grand-total-attribute

enable_debug() {
        set -x
        shopt -s extdebug
        NH_BACKTRACE=true
}
if test -n "${NH_DEBUG}"
then enable_debug
fi

backtrace() {
   if test -z "${NH_BACKTRACE}"
   then return 0
   fi
   ## Source: http://www.runscripts.com/support/guides/scripting/bash/debugging-bash/stack-trace
   declare frame=0
   declare argv_offset=0

   echo
   echo "Backtrace:" >&2
   while caller_info=( $(caller $frame) ) ; do
       declare argv=()
       declare argc
       declare frame_argc

       for ((frame_argc=${BASH_ARGC[frame]}, frame_argc--, argc=0; frame_argc >= 0; argc++, frame_argc--)) ; do
           argv[argc]=${BASH_ARGV[argv_offset+frame_argc]}
           case "${argv[argc]}" in
               *[[:space:]]*) argv[argc]="'${argv[argc]}'" ;;
           esac
       done
       argv_offset=$((argv_offset + ${BASH_ARGC[frame]}))
       printf "  ${frame}: line %4d: ${FUNCNAME[frame]} ${argv[*]}\n" "${caller_info[0]}" >&2
:
       frame=$((frame+1))
   done

   if [[ $frame -eq 1 ]] ; then
       caller_info=( $(caller 0) )
       echo ":: ${caller_info[2]}: Line ${caller_info[0]}: ${caller_info[1]}" >&2
   fi
}
errexit() {
  local err=$?
  set +o xtrace
  local code="${1:-1}"
  echo "Error in ${BASH_SOURCE[1]}:${BASH_LINENO[0]}. '${BASH_COMMAND}' exited with status $err" >&2
  # Print out the stack trace described by $function_stack
  backtrace
  exit "${code}"
}
fail() { echo "FATAL: $*" >&2; backtrace; exit 1;
       }
fail_untraced() { echo "FATAL: $*" >&2; exit 1;
       }

ATEXIT_REMOVE_FILES=
atexit_remove_files() {
	rm -f ${ATEXIT_REMOVE_FILES}
}

cons_by() {
        local attr="$1"; shift

        echo -n "${attr} "
        "$@" ${attr}
}
test_is() {
        local VALUE="$1"; shift
        test "$($*)" = "${VALUE}"
}
map() {
        local ACTION="$1"; shift
        for x in "$@"
        do ${ACTION} "$x"
        done
}
map1() {
        local ACTION="$1"; shift
        local ARG1="$1";  shift
        for x in "$@"
        do ${ACTION} "${ARG1}" "$x"
        done
}
map2() {
        local ACTION="$1"; shift
        local ARG1="$1";  shift
        local ARG2="$1";  shift
        for x in "$@"
        do ${ACTION} "${ARG1}" "${ARG2}" "$x"
        done
}
when() { local pred="$1"; shift; if test -n "${pred}"; then "$@"; fi
       }
iff() { local yes="$1"; local no="$2"; shift 2
        if "$@"
        then echo -n "$yes"
        else echo -n "$no"
        fi
}

init_pkgdb() {
        set -x
        local dir="$1"
        local force="$2"

        if   test -e "${dir}" -a "${force}" != "--force"
        then fail "cannot make a new override database at '${dir}': already exists"
        elif test -z "${dir}"
        then fail "override DB location not specified"
        fi

        mkdir -p ${dir}/def/{over,meta,github,hackage}
        mkdir -p ${dir}/cache
        mkdir -p ${dir}/build/{log,drv,expr,src,success,failure{,-type,-log}}
        rm -f ${dir}/def/{over,meta,github,hackage}/*
        rm -f ${dir}/cache/*
        rm -f ${dir}/build/{log,drv,expr,src,success,failure{,-type,-log}}/*
        exit 0
}
validate_pkgdb() {
        local pkgdb="$1"
        test    -d ${pkgdb}/def/over    \
             -a -d ${pkgdb}/def/meta    \
             -a -d ${pkgdb}/def/github  \
             -a -d ${pkgdb}/def/hackage \
             -a -d ${pkgdb}/cache       \
             -a -d ${pkgdb}/build
}
# Simulate disjoint types
LOGTY=build/log
DRVTY=build/drv
EXPRTY=build/expr
SRCTY=build/src
SUCCTY=build/success
FAILTY=build/failure
FAILTYTY=build/failure-type
FAILLOGTY=build/failure-log

emit_nh_config() {
        local PKGDB="$1"
        cat <<EOF
GHC=${DEFAULT_GHC}
GHC_CONFIG=${DEFAULT_GHC_CONFIG}
PKGDB=${PKGDB}  # The override state database.
NIX_GHC_OVERRIDES=overrides.nix        # The job of 'nh' is to help you maintain this.
NIX_GHC_PACKAGE_SET=packages.nix       # Define a proper GHC package set.
EOF
}

emit_packages_nix() {
        cat <<EOF
{ nixpkgs     ? import <nixpkgs> {}
, pkgs        ? nixpkgs.pkgs, haskell ? pkgs.haskell
, compiler    ? "ghc${DEFAULT_GHC}"
, ghcOrig     ? pkgs.haskell.packages."\${compiler}"
}:

ghcOrig.override (oldArgs: {
    overrides = new: old:
    import ./overrides.nix { inherit pkgs; self = new; super = old; haskellLib = haskell.lib; };
  })
EOF
}

emit_shell_nix() {
        cat <<EOF
{ nixpkgs     ? import <nixpkgs> {}
, pkgs        ? nixpkgs.pkgs, haskell ? pkgs.haskell
, compiler    ? "ghc${GHC}"
, ghcOrig     ? pkgs.haskell.packages."\${compiler}"
, tools       ? false
, intero      ? tools
}:
let

  ghc     = import ./packages.nix { inherit nixpkgs pkgs haskell compiler ghcOrig; };
  default = import ./.;
  drv     = ghc.callPackage default {};
  drv'    = haskell.lib.overrideCabal
            drv
            (old: {
              libraryHaskellDepends =
                old.libraryHaskellDepends
                ++ [ pkgs.cabal-install ];
             });
in
  drv'.env
EOF
}

if   test -f .nh
then true
elif test "$1" = "--auto-init"
then shift
     emit_nh_config      "pkgdb" > .nh
     emit_packages_nix           > packages.nix
     if ! validate_pkgdb "pkgdb"
     then init_pkgdb     "pkgdb" --force
     fi
else cat << EOF
ERROR: the .nh configuration file is not present in the working directory.

Consider the following:  cat > .nh

$(emit_nh_config /home/user/configuration-ghc84x)

Don't have packages.nix?  cat > packages.nix

$(emit_packages_nix)

EOF
     exit 1
fi

source .nh

if test "$1" = "init"
then shift; init_pkgdb "$@"; fi

if test -z "${PKGDB}" || ! validate_pkgdb "${PKGDB}"
then fail_untraced ".nh doesn't define PKGDB to point to a valid package database."; fi

if test -z "${NIX_GHC_PACKAGE_SET}"  -o ! -r ${NIX_GHC_PACKAGE_SET}
then fail_untraced ".nh doesn't define NIX_GHC_PACKAGE_SET to point to a readable file."; fi

NIXPKGS="$(nix-instantiate --eval -E '<nixpkgs>')"
if test $? != 0 -o -z "$NIXPKGS"
then fail "Unable to find Nixpkgs:  nix-instantiate --eval -E '<nixpkgs>'"
fi

if ! type nix-prefetch-git >/dev/null
then fail "missing tool:  nix-prefetch-git   (fix: nix-env -i nix-prefetch-scripts)"
fi

GHC_CONFIG_FULL_PATH=${NIXPKGS}/pkgs/development/haskell-modules/${GHC_CONFIG}

NIX_BUILD_OPTIONS="--argstr compiler ghc${GHC} --show-trace --cores 0"

ensure_trailing_newline() {
	sed '$a\'
}
prefix_lines() {
        prefix="$1"
	sed "s/^/${prefix}/; s/[ ]*\$//"
}

path() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"

        echo ${PKGDB}/${TYPE}/${NAME}.${FIELD}
}
_ls() {
        # List all overridden attributes.
        # NOTE:  this includes attributes whose overrides are disabled by meta/disable.
        local TYPE="${1:-def/over}"

        pushd ${PKGDB}/${TYPE} >/dev/null

        case $TYPE in
                def/github | def/hackage )                 ls -1 *.${2:-hash} 2>/dev/null | sed "s/\\.${2:-hash}//";;
                def/over | build/success | build/failure ) ls -1 *            2>/dev/null | grep -v "\\.baseline$" | sed 's/^\(.*\)\.[^\.]*$/\1/' | sort | uniq;;
                * ) echo "FATAL: listing of '${TYPE}' is not supported" >&2; popd; return 1;;
        esac | sort
        popd >/dev/null
}
lsattrs() {
        local TYPE="$1"; shift
        local NAME="$1"; shift

        pushd ${PKGDB}/${TYPE} >/dev/null
        ls -1 * 2>/dev/null | grep "^$NAME\\." | grep -v "\\.baseline$" | sed 's/^[^\.]*\.\(.*\)$/\1/'
        popd >/dev/null
}
get() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"

        if test -f ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        then   cat ${PKGDB}/${TYPE}/${NAME}.${FIELD} 2>/dev/null
        else return 1
        fi
}
get_def() {
        local DEFAULT="$4"

        get "$1" "$2" "$3" || echo -n "$DEFAULT"
}
has() {
        test -f $(path "$@")
}
_set() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"
        local VALUE="$4"

        if test -z "${VALUE}"
        then rm -f ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        else echo -n "${VALUE}" > ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        fi
}
set_stdin() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"

        cat > ${PKGDB}/${TYPE}/${NAME}.${FIELD}
}

attrName() {
        local attr="$1"; shift
        get_def def/meta attrName ${attr} "${attr}"
}
repoName() {
        local attr="$1"; shift
        get_def def/meta repoName ${attr} "${attr}"
}
shadow_name() {
        local attr="$1";        shift
        has def/hackage release ${attr} &&
                echo "${attr}_$(get def/hackage release ${attr} | sed 's/\./_/g')"
}
shadows() {
        local attr="$1";        shift
        local nixpkgs="${2:-/home/deepfire/src/nixpkgs}"

        local hackage_packages=${NIXPKGS}/pkgs/development/haskell-modules/hackage-packages.nix

        if test ! -f "${hackage_packages}"
        then echo "FATAL: ${nixpkgs} doesn't point to a valid Nixpkgs checkout"; return 1
        fi

        grep "${attr}_.* = callPackage" ${hackage_packages} | cut -d'"' -f2
}
test_upstreamed() {
        local repo="$(repoName $1)"
        local upstream="$(get def/github upstream $repo)"
        local user="$(get def/github user $repo)"

        test -n "${user}" -a "${user}" = "${upstream}"
}
test_shadow_exists() {
        local attr="$1";        shift

        local shadow=$(shadow_name ${attr} || true)
        test "$(get def/over src $attr)" = "hackage" -a -n "$shadow" && { shadows ${attr} | grep -q "$shadow"; }
}
test_shadowed() {
        local attr="$1";        shift

        test_shadow_exists "${attr}" && ! has def/meta suppress-shadow "${attr}" ## XXX: re-use the 'disable' mechanism
}

by() {
        local TYPE="$1"
        local FIELD="$2"
        local VALUE="$3"
        shift 3

        for x in $(_ls ${TYPE})
        do if test "$(get ${TYPE} ${FIELD} $x)" = "${VALUE}"
           then echo $x
           fi
        done
}

log_filter_failure() {
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        grep '^builder for.*failed with exit code 1' | sed 's|.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|\1|'
}
log_filter_success() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        grep '^checking for references to.* in /nix/store/.*\.\.\.' | sed 's|.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|\1|'
}
log_filter_result() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        grep --line-buffered '^builder for.*failed with exit code 1\|^checking for references to.* in /nix/store/.*[0-9]\.\.\.' | sed 's|^builder for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|FAIL: \1|' | sed 's|checking for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|OK: \1|'
}
log_filter_progress() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        # setupCompileFlags: -package-db=/tmp/nix-build-hedgehog-0.5.1.drv-0/package.conf.d -j8 -threaded
        grep --line-buffered '^builder for.*failed with exit code 1\|^checking for references to.* in /nix/store/.*[0-9]\.\.\.\|setupCompileFlags: -package-db=/tmp/nix-build-.*' | sed 's|^builder for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|FAIL: \1|' | sed 's|checking for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|OK:   \1|' | sed 's|setupCompileFlags: -package-db=/tmp/nix-build-\([a-zA-Z0-9-]*\)-[0-9].*$|NEW:  \1|'
}

drv_src() {
        local over="$1";        shift
        local attr="$1";        shift
        nix-store --query --binding src ${PKGDB}/${DRVTY}/${attr}.${over}
}
evaluation_failure_attributes() {
        local grep_extra="$1"
        grep "while evaluating the attribute${grep_extra}" | sed 's/.*derivation ‘\(.*\)’ at.*/\1/'
}
do_instantiate() {
        local attr="$1"; shift

        if !    nix-instantiate ${NIX_GHC_PACKAGE_SET} -A ${attr} --argstr compiler ghc${GHC} 2>/dev/null
        then
                nix-instantiate ${NIX_GHC_PACKAGE_SET} -A ${attr} --argstr compiler ghc${GHC} --show-trace
                return 1
        fi
}
nreferrers() {
        local attr="$1"

        local drv=$(do_instantiate ${attr})
        local refs=$(nix-store --query --referrers-closure ${drv} | wc -l)
        echo ${refs} ${attr} ${drv}
}

reset_state() {
        mkdir -p ${PKGDB}/{${LOGTY},${DRVTY},${EXPRTY},${SRCTY},${SUCCTY},${FAILTY},${FAILTYTY},${FAILLOGTY}}
        rm -f    ${PKGDB}/{${LOGTY},${DRVTY},${EXPRTY},${SRCTY},${SUCCTY},${FAILTY},${FAILTYTY},${FAILLOGTY}}/* 2>/dev/null ||
                true
}
edit() {
        local TYPE="$1";  shift
        local FIELD="$1"; shift
        local NAME="$1";  shift

        read -ep "${NAME}.${TYPE}.${FIELD}: " -i "$(get ${TYPE} ${FIELD} ${NAME})"
        _set "${TYPE}" "${FIELD}" "${NAME}" "${REPLY}"
}
stdin_forall_edit() {
        local TYPE="$1";  shift
        local FIELD="$1"; shift

        for name in $*
        do
                read -p "${TYPE}.${FIELD} for ${name}: "
                _set "${TYPE}" "${FIELD}" ${name} "${REPLY}"
        done
}
stdin_forall_set() {
        local TYPE="$1"
        local FIELD="$2"
        local VALUE="$3"

        for name in $(cat)
        do _set "${TYPE}" "${FIELD}" ${name} "${VALUE}"
        done
}

test_is_local() {
	has def/meta local "$1"
}
test_is_nonlocal() {
	! has def/meta local "$1"
}
set_local() {
	_set def/meta local "$1" local
}
set_nonlocal() {
	_set def/meta local "$1" ""
}

filter() {
        for attr in $(_ls)
        do if "$@" ${attr} > /dev/null
           then echo ${attr}
           fi
        done
}
filter_by_and() {
        pred="$1"; shift
        for attr in $(_ls)
        do if ${pred} ${attr} > /dev/null \
              && "$@" ${attr} > /dev/null
           then echo ${attr}
           fi
        done
}
overset_config() {
        (
                _ls def/over
                by  def/over src hackage
                by  def/over src github
        ) | sort | uniq -u
}
lstopo() {
        local TYPE="$1"

        local ntotal=$(_ls ${TYPE} | wc -l)
        local ndone=1
        for attr in $(_ls ${TYPE})
        do
                echo -ne "\rComputing topology order: $ndone/$ntotal" >&2
                ndone=$((ndone+1))

                nreferrers ${attr}
        done | sort -nr
        echo >&2
}
get_nixpkgs_release() {
        local attr="$1"; shift

        nix-instantiate --eval -E "(import <nixpkgs> {}).pkgs.haskell.packages.ghc${GHC}.${attr}.version" | xargs echo -n
}
status() {
        local attr="$1"

        case $(get_def def/over src ${attr} maybe-config) in
        hackage ) if test_shadowed "$1"
                  then echo -n "shadowed"
                  else echo -n "hackaged"
                  fi;;
        github  ) if test_upstreamed "$1"
                  then echo -n "upstreamed"
                  else echo -n "unmerged"
                  fi;;
        maybe-config )
                  if test -n "$(lsattrs def/over $1)"
		  then echo -n "config"
		  else echo -n "default"
                  fi;;
        * )       echo "FATAL: invalid status for '${attr}': '$(get def/over src ${attr})'";;
        esac
}
ls_essential_reverse_deps() {
        for attr in $(_ls)
        do get def/meta erdeps ${attr} | xargs echo
        done | sed $'s/ /\\\n/'g | sort | uniq
}
ls_extra_validation_attributes() {
        get_def def/meta extra-validation-attributes
}
ls_acme_deps() {
        _ls
        ls_essential_reverse_deps
        ls_extra_validation_attributes
}

get_log() {
        local over="$1"; shift
        local attr="$1"; shift

        get ${LOGTY} ${over} ${attr}
}
faillog() {
        local over="$1"
        local attr="$2"

        test "$(get ${FAILTYTY} ${over} ${attr})" != UNKNOWN || {
                echo "WARNING: failure type UNKNOWN for:  ${attr}.${over}" >&2
                echo "WARNING: analyse (and maybe populate 'keysig'):  nh log ${attr} ${over}" >&2
                return 1
        }
        get ${FAILLOGTY} ${over} ${attr}
}

prOrFail() {
        local repo="$1"
        get def/github pr $repo || {
                echo "FATAL:  pull-request not specified for github repo '${repo}'" >&2
                fail " logs:  get def/github pr ${repo}"
        }
}
issueOrFail() {
        local repo="$1"
        get def/github issue $repo || {
                echo "FATAL:  issue ID not specified for github repo '${repo}'" >&2
                fail " logs:  get def/github issue ${repo}"
        }
}
url() {
        local KIND="$1"; shift
        local attr="$1"; shift

        local subpath=
        local gitrev=master
        local release=
        while test $# -ge 1
        do case "$1"
           in --subpath )              subpath="$2"; shift;;
              --gitrev )               gitrev="$2";  shift;;
              --pull-request )         pull_request="$2";  shift;;
              --issue )                issue="$2";  shift;;
              --release )              release="$2"; shift;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )     break;;
           esac
           shift
        done

        local repo="$(repoName "$attr")"
        case "${KIND}" in
                upstream-github-cabal )      echo -n "https://raw.githubusercontent.com/$(get def/github upstream $repo)/$repo/${gitrev}/$subpath$attr.cabal";;
                user-github-cabal )          echo -n "https://raw.githubusercontent.com/$(get def/github user     $repo)/$repo/${gitrev}/$subpath$attr.cabal";;
                upstream-github )            echo -n "https://github.com/$(               get def/github upstream $repo)/$repo";;
                upstream-pull-request )      echo -n "https://github.com/$(               get def/github upstream $repo)/$repo/pull/$(prOrFail $repo)";;
                upstream-issue )             echo -n "https://github.com/$(               get def/github upstream $repo)/$repo/issues/$(issueOrFail $repo)";;
                commits | upstream-commits ) echo -n "https://github.com/$(               get def/github upstream $repo)/$repo/commits/master";;
                user-commits )               echo -n "https://github.com/$(               get def/github user     $repo)/$repo/commits/master";;
                github-prs )                 echo -n "https://github.com/$(               get def/github upstream $repo)/$repo/pulls";;
                hackage )                    echo -n "https://hackage.haskell.org/package/$attr";;
                hackage-package )            echo -n "https://hackage.haskell.org/package/$attr-$release/$attr-$release.tar.gz";;
                pull-merged )                echo -n "https://api.github.com/repos/$(     get def/github user     $repo)/$repo/pulls/$(prOrFail $repo)/merge";;
                commit )                     echo -n "https://api.github.com/repos/$(     get def/github user     $repo)/$repo/commits?sha=${gitrev}";;
                github-requests-remaining )  echo -n "https://api.github.com/rate_limit";;
                * ) fail "invalid URL kind: '$KIND'";;
        esac
}

endpoint_head() {
        curl -sI $(url "$@")
}
endpoint_test_status() {
        local status="$1"; shift
        endpoint_head "$@" | grep -q "${status}"
        test ${PIPESTATUS[0]} = 0 -a ${PIPESTATUS[1]} = 0
}
endpoint_field() {
        local field="$1"; shift
        endpoint_head "$@" | grep "^${field}: " | cut -d' ' -f2-
        test ${PIPESTATUS[0]} = 0
}

test_hackage_release() {
        local release="$1"; shift
        local attr="$1"; shift

        endpoint_test_status 'HTTP/1.1 200 OK' hackage-package ${attr} --release ${release}
}
hackage_release_date() {
        local attr="$1"; shift
        local release="$1"; shift

        ret="$(endpoint_field 'Last-modified' hackage-package ${attr} --release ${release})"
        if test -z "${ret}"
        then return 1
        else echo "${ret}"
        fi
}
hackage_release_timestamp() {
        date=$(hackage_release_date "$@")
        if test $? != 0
        then return 1
        fi
        date -d "$date" +%s
}

fix_commit() {
        local attr="$1"; shift

        get def/github rev $(repoName "${attr}")
}
commit_date() {
        local attr="$1"; shift
        local gitrev="${1:-master}"

        endpoint_field "Last-Modified" commit "${attr}" --gitrev "${gitrev}"
        return ${PIPESTATUS[0]}
}
commit_timestamp() {
        date="$(commit_date "$@")"
        if test $? != 0
        then return 1
        fi
        date -d "$date" +%s
}
fix_timestamp() {
        local attr="$1"; shift
        get def/github timestamp $(repoName "${attr}")
}

fetch_cabal() {
        local kind="$1"; shift
        local attr="$1"; shift
        local gitrev="${1:-master}"
        local chdir="$(get_def def/meta chdir $attr '')"

        curl -sL $(url ${kind}-github-cabal $(attrName ${attr}) --subpath "${chdir}${chdir:+/}" --gitrev "${gitrev}")
}

get_upstream_release() {
        local attr="$1"
        local gitrev="${2:-master}"
        fetch_cabal upstream ${attr} ${gitrev} | grep -i '^version:' | sed 's/[vV]ersion:[ ]*//'
}
get_user_release() {
        local attr="$1"
        local gitrev="${2:-master}"
        fetch_cabal user ${attr} ${gitrev} | grep -i '^version:' | sed 's/[vV]ersion:[ ]*//'
}



github_pr_status() {
        local attr="$1"
        local repo="$(repoName "$attr")"
        local pull_request="$(get_def def/github pr ${repo} '')"


        local http_code="$(endpoint_head pull-merged ${attr} --pull-request ${pull_request} | grep 'HTTP/1.1')"

        if   echo "${http_code}" | grep -q "204 No Content"
        then echo -n "merged"
        elif echo "${http_code}" | grep -q "404 Not Found"
        then echo -n "unmerged"
        else return 1
        fi
}

github_issue_state() {
        local attr="$1"
        local repo="$(repoName "$attr")"
        local issue="$(get_def def/github issue ${repo} '')"

        local state="$(endpoint_head issue ${attr} --issue ${issue} | grep '^  "state": ' | cut -d'"' -f4)"

        case "${state}" in
             open | closed ) echo ${state};;
             * )             return 1;;
        esac
}

less2line() {
        local file="$1"
        local pattern="$2"
        less --pattern="$2" "$1"
}

function V() # $1-a $2-op $3-$b
# Author: stepse@StackOverflow: https://stackoverflow.com/a/48487783
# Compare a and b as version strings. Rules:
# R1: a and b : dot-separated sequence of items. Items are numeric. The last item can optionally end with letters, i.e., 2.5 or 2.5a.
# R2: Zeros are automatically inserted to compare the same number of items, i.e., 1.0 < 1.0.1 means 1.0.0 < 1.0.1 => yes.
# R3: op can be '=' '==' '!=' '<' '<=' '>' '>=' (lexicographic).
# R4: Unrestricted number of digits of any item, i.e., 3.0003 > 3.0000004.
# R5: Unrestricted number of items.
{
  local a=$1 op=$2 b=$3 al=${1##*.} bl=${3##*.}
  while [[ $al =~ ^[[:digit:]] ]]; do al=${al:1}; done
  while [[ $bl =~ ^[[:digit:]] ]]; do bl=${bl:1}; done
  local ai=${a%$al} bi=${b%$bl}

  local ap=${ai//[[:digit:]]} bp=${bi//[[:digit:]]}
  ap=${ap//./.0} bp=${bp//./.0}

  local w=1 fmt=$a.$b x IFS=.
  for x in $fmt; do [ ${#x} -gt $w ] && w=${#x}; done
  fmt=${*//[^.]}; fmt=${fmt//./%${w}s}
  printf -v a $fmt $ai$bp; printf -v a "%s-%${w}s" $a $al
  printf -v b $fmt $bi$ap; printf -v b "%s-%${w}s" $b $bl

  case $op in
    '<='|'>=' ) [ "$a" ${op:0:1} "$b" ] || [ "$a" = "$b" ] ;;
    * )         [ "$a" $op "$b" ] ;;
  esac
}

hackage_ahead_of_fix() {
        local attr="$1"
        local upstream_release=$(get_upstream_release ${attr})
        if test_hackage_release ${upstream_release} ${attr}
        then
                local hackage_timestamp=$(hackage_release_timestamp ${attr} ${upstream_release})
                local fix_stamp=$(fix_timestamp ${attr})
                test ${fix_stamp} -le ${hackage_timestamp}
        else
                return 1
        fi
}

promote_to_hackage() {
        local attr="$1"
        local release="$2"
        local upstream_master_release="$3"

        if test_hackage_release "${upstream_master_release}" ${attr}
        then hackage ${attr} "${upstream_master_release}"
        else warn "AUTOMATIC FIX STALLED: github release version (${upstream_master_release}) has not been put on Hackage yet"
             echo -n "New Hackage release for ${attr}: "
             read release
             hackage ${attr} "${release}"
        fi
}

github_requests_remaining() {
        endpoint_field "X-RateLimit-Remaining" github-requests-remaining
}

cache_gen_override_one() {
        local attr="$1"
        local REQUIRE_DESC="$2"

        emit_override ${attr} "${REQUIRE_DESC}" | set_stdin cache override ${attr}
        if test ${PIPESTATUS[0]} != 0
        then fail "failed to compute override for ${attr}"
        fi
}

coherently() {
        local reuse_cache=
        local reuse_overrides=
        local require_desc=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --require-desc )         require_desc="--require-desc";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local attr=$1; shift
        local over=$1; shift

        emit_override ${attr} ${require_desc} | set_stdin cache override ${attr}
        if test ${PIPESTATUS[0]} != 0
        then fail "failed to compute override ${attr}"
        fi
        get cache override ${attr}

	# Record the overall expression used.
        if test ${over} = "baseline"
        then if test -z "${reuse_overrides}"
             then emit_overrides ${reuse_cache} | tee ${PKGDB}/${EXPRTY}/baseline        > ${NIX_GHC_OVERRIDES}
             else cp -f ${NIX_GHC_OVERRIDES}          ${PKGDB}/${EXPRTY}/baseline
             fi
        else      emit_overrides ${reuse_cache} | tee ${PKGDB}/${EXPRTY}/${attr}.${over} > ${NIX_GHC_OVERRIDES}
        fi

        "$@"
}
cache_copy() {
        local FIELD_FROM="$1"; shift
        local FIELD_TO="$1";   shift

        pushd ${PKGDB}/cache >/dev/null
        for from in *.${FIELD_FROM}
        do
                to="$(echo $from | sed 's/^\(.*\)\.[^\.]*$/\1/')".${FIELD_TO}
                cp -f "${from}" "${to}"
        done
	popd >/dev/null
}

emit_explanation() {
        local over="$1"; shift
        local attr="$1"; shift

        if test -z "${over}"
        then case $(status ${attr}) in
                     shadowed   ) echo "Needs bump to a versioned attribute";;
                     hackaged   ) echo "On Hackage, awaiting for import";;
                     upstreamed ) echo "Upstreamed, awaiting a Hackage release";;
                     unmerged   ) echo "Unmerged.  PR: $(url upstream-pull-request ${attr})";;
             esac
             local repo="$(repoName "$attr")"
             if has def/github issue ${repo}
             then echo "Issue: $(url upstream-issue ${attr})"
             fi
        fi
        faillog ${over} ${attr}                  | ensure_trailing_newline
	get def/meta ${over}.explanation ${attr} | ensure_trailing_newline
}
emit_src_description() {
        local attr="$1";         shift

        case "$(get def/over src ${attr})" in
                hackage )    echo "    ## Hackage import needed";;
                github )
                        if test_upstreamed "${attr}"
                        then echo "    ## Fixes upstreamed, awaiting Hackage release"
                        else echo "    ## Fixes not upstream yet"
                        fi;;
        esac
}
fail_uncached() {
        echo -e "\nFATAL: attribute $1 has no override cache" >&2
        exit 1
}
emit_property_override() {
        local attr="$1"; shift
        local propName="$1"
        eval "${propName}=\"$(get_def def/over ${propName} ${attr})\""
        eval propVal=\$$propName
        if test ! -z "${propVal}" && ! has def/meta disable.${propName} ${attr}
        then
                emit_explanation ${propName} ${attr} | prefix_lines "    ## "
                if test ! -z "${REQUIRE_DESC}" -a ${PIPESTATUS[0]} != 0
                then fail "missing failure log for ${attr}.${propName}, and couldn't compute it either:  nh x emit_explanation ${propName} ${attr}"
                fi
                case "${propName}" in
                        src )
                                case "$src" in
                                        hackage )
                                                if test_shadowed "${attr}"
                                                then echo "    ##"
                                                else
                                                cat <<EOF
    version         = "$(get def/hackage release ${attr})";
    sha256          = "$(get def/hackage hash    ${attr})";
EOF
                                                fi;;
                                        github )
                                                repo=$(repoName ${attr})
                                                cat <<EOF
    src = pkgs.fetchFromGitHub {
      owner  = "$(get def/github user ${repo})";
      repo   = "${repo}";
      rev    = "$(get def/github rev  ${repo})";
      sha256 = "$(get def/github hash ${repo})";
    };
EOF
                                                if has def/meta chdir ${attr}
                                                then echo "    prePatch        = \"cd $(get def/meta chdir ${attr}); \";"
                                                fi;;
                                        * )     fail "unknown value for src override: '$src'";;
                                esac;;
                        doCheck )          echo "    doCheck         = ${doCheck};";;
                        doHaddock )        echo "    doHaddock       = ${doHaddock};";;
                        jailbreak )        echo "    jailbreak       = ${jailbreak};";;
                        editedCabalFile )  echo "    editedCabalFile = ${editedCabalFile};";;
                        revision )         echo "    revision        = ${revision};";;
                        postPatch )        echo "    postPatch       = \"${postPatch}\";";;
                        extraLibs )        echo "    libraryHaskellDepends = drv.libraryHaskellDepends ++ ${extraLibs};";;
                        * ) fail "unknown property: '${propName}'";;
                esac
        fi
}
emit_override() {
        local attr="$1"
        local base_attr=""

        if test -z "$(lsattrs def/over ${attr})" ||   has def/meta disable     "${attr}"
        then return
        fi
        if test_shadowed "${attr}"               && ! has def/meta disable.src "${attr}"
	then shadowed=yes; base_attr="$(shadow_name ${attr})"
        else shadowed=;    base_attr="${attr}"
        fi
        emit_explanation ""  ${attr} | prefix_lines "  ## " # Print general context first
        if test -n "${shadowed}" && test "$(lsattrs def/over ${attr} | xargs echo -n)" = "src"
        then
                emit_explanation src ${attr} | prefix_lines "  ## "
                cat <<EOF
  ${attr} = super.${base_attr};

EOF
        else
                cat <<EOF
  ${attr} = overrideCabal super.${base_attr} (drv: {
EOF
                props="src doCheck doHaddock jailbreak editedCabalFile revision postPatch extraLibs"
                for p in ${props}
                do emit_property_override ${attr} $p
                done
                cat <<EOF
  });

EOF
        fi
}
do_emit_overrides() {
        predicate="true"
        while test $# -ge 1
        do case "$1"
           in --target )               case "$2" in
                                           local )   predicate=test_is_local;    shift;;
                                           nixpkgs ) predicate=test_is_nonlocal; shift;;
                                           * ) fail "unexpected --target: '$2'";; esac;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done
        cat <<EOF
  ## Shadowed:

EOF
        for attr in $(filter_by_and ${predicate} test_is shadowed status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## On Hackage:

EOF
        for attr in $(filter_by_and ${predicate} test_is hackaged status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## Upstreamed

EOF
        for attr in $(filter_by_and ${predicate} test_is upstreamed status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## Unmerged

EOF
        for attr in $(filter_by_and ${predicate} test_is unmerged status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## Non-code, configuration-only change

EOF
        for attr in $(filter_by_and ${predicate} test_is config status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done
}
emit_overrides() {
        local emit_acme=
        local format=overrides
        local nixpkgs=
        local reuse_cache=
        local require_descs=
        local silent=
        local target=
        while test $# -ge 1
        do case "$1"
           in --emit-acme )            emit_acme="--emit-acme";;
              --format )               format=$2; shift;;
              --nixpkgs )              true;;                             ## Expected to be handled by caller
              --reuse-cache )          reuse_cache="--reuse-cache";;
              --require-descs )        require_descs="--require-descs";;
              --silent )               silent="--silent";;
              --target )               case "$2" in
                                           local | nixpkgs ) target=$2; shift;;
                                           * ) fail "unexpected --target: '$2'";; esac;;
              --debug )                enable_debug;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        ###
        ### 1. Generate override cache
        ###
        if test -z "${reuse_cache}"
        then cache ${require_descs} ${silent} "$@" ||
                 fail "cache generation failed" >&2
        fi

        echo -n "Assembling overrides.." >&2
        ###
        ### 2. Emit overrides
        ###
        case ${format} in
        overrides )
                cat <<EOF
{ pkgs, haskellLib, super, self }:

with haskellLib; with self; {
EOF
                           ;;
        configuration-ghc )
                cat <<EOF
{ pkgs, haskellLib }:

with haskellLib;

self: super: {

EOF
                emit_ghc_configuration_fixed_content;;
        * )
                fail "Unsupported --format for emit_overrides: '${format}'";;
        esac
        echo

        if test -z "${suppress_content}"
        then do_emit_overrides ${target:+--target ${target}}
        fi

        if test -n "${emit_acme}"
        then
                cat <<EOF

  ## The catch-all attribute that depends on everything overridden (incl. meta/disabled things).
  ${ACME_ATTRIBUTE} = self.mkDerivation {
    pname = "${ACME_ATTRIBUTE}";
    version = "0.0.0";
    src = ./.;
    isLibrary = true;
    isExecutable = true;
    libraryHaskellDepends = [
      $(ls_acme_deps)
    ];
    license = stdenv.lib.licenses.bsd3;
  };
EOF
        fi
        cat <<EOF
}
EOF
        echo " done." >&2
}
emit_ghc_configuration_fixed_content() {
        get_def def/meta ghc-configuration-fixed-content
}

override_builder() {
        while test $# -ge 1
        do case "$1"
           in "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local attr="$1"; shift
        local over="$1"; shift

        ###
        ### 1. Instantiate
        ###
        local store_drv="$(do_instantiate ${attr})"
	local status=$?
	if test ${status} = 0 -a -n "${store_drv}"
	then
	        rm -f            ${PKGDB}/${DRVTY}/${attr}.${over}
	        ln -s $store_drv ${PKGDB}/${DRVTY}/${attr}.${over}
        	local store_src="$(drv_src ${over} ${attr})"
	        rm -f            ${PKGDB}/${SRCTY}/${attr}.${over}
	        ln -s $store_src ${PKGDB}/${SRCTY}/${attr}.${over}
	else
		{ do_instantiate ${attr} 2>&1 || true; } |
    			set_stdin          ${LOGTY} ${over} ${attr}
                echo "FATAL: failed to instantiate '${attr}', without overriding '${over}'" >&2
                echo "FATAL: logs:  nh log ${attr} ${over}" >&2
                _set ${FAILTY}   ${over} ${attr} "INSTANTIATE"
                fail_classify_one_property ${over} ${attr}
		## TODO:  invoke the loop hunter?
                return 1
	fi

        ###
        ### 2. prebuild context
        ###
        echo -n      "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-shell ${NIX_GHC_PACKAGE_SET} -A ${attr} ${NIX_BUILD_OPTIONS} --no-out-link 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        local status=${PIPESTATUS[0]}
        if test ${status} != 0
        then
                echo "FATAL: failed to prebuild deps of '${attr}', without overriding '${over}'" >&2
                intermediate_failure=$(get ${LOGTY} "${over}" ${attr} | log_filter_failure)
		if test -n "${intermediate_failure}"
		then
                	echo "FATAL: ..apparently due to:  ${intermediate_failure}"
                	echo "FATAL: logs:  nh log ${attr} ${over}" >&2
		fi
                _set ${FAILTY}   ${over} ${attr} "DEPENDENCY/${intermediate_failure:-UNKNOWN}"
                fail_classify_one_property ${over} ${attr}
                return 1
        fi

        ###
        ### 3. build
        ###
        echo -n      "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-build ${NIX_GHC_PACKAGE_SET} -A ${attr} ${NIX_BUILD_OPTIONS} 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        status=${PIPESTATUS[0]}
        rm -f ${PKGDB}/current.build
        if test ${status} = 0
        then
                local drv=$(readlink result)
                rm -f result
        else
                echo "FATAL: failed to build '${attr}', without overriding '${over}'" >&2
                echo "FATAL: logs:  nh log ${attr} ${over}" >&2
                _set ${FAILTY}   ${over} ${attr} "DIRECT"
                fail_classify_one_property ${over} ${attr}
                return 1
        fi

        ###
        ### 3. build essential rdeps
        ###
        for erdep in $(get def/meta erdeps ${attr})
        do
                echo -n "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
                nix-build ${NIX_GHC_PACKAGE_SET} -A ${erdep} ${NIX_BUILD_OPTIONS} 2>&1 \
                        | set_stdin ${LOGTY} ${over} ${attr}
                status=${PIPESTATUS[0]}
                rm -f ${PKGDB}/current.build
                if test ${status} != 0
                then
                        echo "FATAL: essential rev-dependency '${erdep}' breaks, without overriding '${attr}'s '${over}'" >&2
                        echo "FATAL: logs:  nh get ${LOGTY} ${over} ${attr}" >&2
                        _set ${FAILTY} ${over} ${attr} "ESSENTIAL-REVERSE ${erdep}"
                        fail_classify_one_property ${over} ${attr}
                        return 1
                fi
        done
        _set ${SUCCTY}    ${over} ${attr} $drv
        _set ${FAILTY}    ${over} ${attr} ""
        _set ${FAILLOGTY} ${over} ${attr} ""
        _set ${FAILTYTY}  ${over} ${attr} ""
        return 0
}

WFV_TYPE=
WFV_FIELD=
WFV_NAME=
WFV_SAVE_VAL=
with_field_value_atexit() {
        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${WFV_SAVE_VAL}"
        cache_gen_override_one "${WFV_NAME}"
}
with_field_value() {
        update_cache=
        while test $# -ge 1
        do case "$1"
           in --debug )                enable_debug;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        WFV_TYPE="$1";    shift
        WFV_FIELD="$1";   shift
        WFV_NAME="$1";    shift
        local value="$1"; shift

        WFV_SAVE_VAL="$(get_def ${WFV_TYPE} ${WFV_FIELD} ${WFV_NAME} '')"
        # test ! -z "${SAVE_VAL}" || {
        #         echo "FATAL: '${OVER}' isn't specified for attribute  '${ATTR}'"
        #         exit 1
        # }

        trap with_field_value_atexit EXIT

        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${value}"
        cache_gen_override_one "${WFV_NAME}"

        "$@"
        result=$?
        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${WFV_SAVE_VAL}"
        cache_gen_override_one "${WFV_NAME}"
        return $result
}

build() {
        reuse_cache=
        reuse_overrides=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --debug )                enable_debug;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done
        local attr=$1; shift
        local over=${1:-baseline}

        coherently ${reuse_cache} ${reuse_overrides} ${attr} "${over}" override_builder ${attr} "${over}"
}

declare -a keysig
keysig=(
"CABAL-MISSING-DEPS||||Setup: Encountered missing dependencies"
"HASKELL-SMP-NO-INSTANCE-FOR||||No instance for \(Semigroup"
"HASKELL-SMP-COULD-NOT-DEDUCE||||Could not deduce \(Semigroup"
"HASKELL-SMP-APPEND-CONFLICT||||Ambiguous occurrence ‘<>’"
"HASKELL-SMP-NO-INSTANCE-IMPL-FOR||||No instance nor default method for class operation <>"
"HASKELL-SMP-VERSION||||Module ‘Data.Semigroup’ does not export ‘"
"GHC-BUG||||Please report this as a GHC bug"
"CABAL-NOT-FOUND||||/bin/sh: cabal: command not found"
"NO-SUCH-FILE-OR-DIRECTORY||||: No such file or directory"
"NIX-ERROR-EVAL-OVERRIDECABAL||||error: while evaluating ‘overrideCabal’"
"JAILBREAK-CABAL-MISSING-CABAL||||jailbreak-cabal: dieVerbatim: user error \(jailbreak-cabal: Error Parsing: file "
"CABAL-CONFIGURE-MISSING-PROGRAM||||Setup: The program '[A-Za-z-]*' is required but it could not be found"
"NIX-MISSING-ATTRIBUTE||||error: attribute ‘[A-Za-z-]*’ in selection path ‘[A-Za-z-]*’ not found"
"HASKELL-MISSING-EXPORT||||Module ‘[A-Za-z-]*’ does not export ‘"
"HASKELL-AMBIGUOUS-TYPE-VARIABLE-ERROR||||Ambiguous type variable"
"HASKELL-TYPE-ERROR||||Couldn't match expected type"
"HASKELL-MISSING-INSTANCE||||No instance for \("
"HASKELL-CONTEXT-NOT-SATISFIED||||Could not deduce \("
"HASKELL-MISSING-MODULE||||Could not find module ‘"
"HASKELL-VAR-NOT-IN-SCOPE||||Variable not in scope:"
"CURL-404||||The requested URL returned error: 404 Not Found"
"NO-SUCH-FILE-OR-DIRECTORY||||No such file or directory"
"NO-CABAL-FILE-FOUND||||Setup: No cabal file found"
"TH-RUNTIME-EXCEPTION||||Exception when trying to run compile-time code:"
"INSTANTIATE-INFINITE-RECURSION||||infinite recursion encountered, at undefined"
"INSTANTIATE-GENERIC||||error: while evaluating the attribute"
"HADDOCK-INTERNAL-ERROR||||haddock: internal error:"
)
declare -A grepctx
grepctx["CABAL-MISSING-DEPS"]="-A5"
grepctx["HASKELL-SMP-NO-INSTANCE-FOR"]="-A2"
grepctx["HASKELL-SMP-COULD-NOT-DEDUCE"]="-A2"
grepctx["HASKELL-SMP-APPEND-CONFLICT"]="-A2"
grepctx["HASKELL-SMP-VERSION"]="-A2"
grepctx["GHC-BUG"]="-B30"
grepctx["HASKELL-TYPE-ERROR"]="-A3"
grepctx["HASKELL-MISSING-INSTANCE"]="-A2"
grepctx["HASKELL-CONTEXT-NOT-SATISFIED"]="-A2"
grepctx["CURL-404"]="-A1"
grepctx["TH-RUNTIME-EXCEPTION"]="-B1 -A7"
grepctx["INSTANTIATE-INFINITE-RECURSION"]="-B10"
grepctx["INSTANTIATE-GENERIC"]="-A7"
grepctx["HADDOCK-INTERNAL-ERROR"]="-A7"

fail_classify_one_property() {
        local over="$1";      shift
        local attr="$1";      shift
        local no_state_change="$1"

        for ks in "${keysig[@]}"
        do key="${ks%%||||*}"; sig="${ks#*||||}"
           if      get_log ${over} ${attr} | egrep --max-count=1 -q                 "${sig}"
           then
                   echo "${key}"
                   if test -z "${no_state_change}"
                   then _set ${FAILTYTY} ${over} ${attr} "${key}"
                   fi
                   get_log ${over} ${attr} | egrep --max-count=1 ${grepctx["${key}"]} "${sig}" \
			| grep -v "^$\|^builder for ‘/nix/store/\|^error: build of ‘/nix/store/" |
                           { if test -n "${no_state_change}"
                             then cat
                             else tee $(path ${FAILLOGTY} ${over} ${attr})
                             fi; }
                   return 0
           fi
        done
        echo UNKNOWN
        _set ${FAILTYTY} ${over} ${attr} UNKNOWN
        return 1
}

show_trims() {
        for attr in $(_ls ${SUCCTY})
        do
                trimset="$(lsattrs ${SUCCTY} ${attr} | xargs echo -n)"
                if test "${trimset}" = "default"
                then trimset="$(lsattrs def/over ${attr} | xargs echo -n)"
                fi

                for over in ${trimset}
                do if has  def/meta ${over}.explanation ${attr}
                   then echo "KEEP ${attr}.${over}>  it has an explanation"
                   else echo "TRIM>  ${attr}.${over}"
                   fi
                done
        done
}
execute_trims() {
        for attr in $(_ls ${SUCCTY})
        do
                trimset="$(lsattrs ${SUCCTY} ${attr} | xargs echo -n)"
                if test "${trimset}" = "default"
                then
                        echo "--( ${attr} now entirely redundant"
                        trimset="$(lsattrs def/over ${attr} | xargs echo -n)"
                fi

                echo "--( ${attr} trimmable: ${trimset}"
                for over in ${trimset}
                do if ! has  def/meta ${over}.explanation ${attr}
                   then _set def/over ${over} ${attr} ""
                   else echo "---( keeping ${over}, since it has an explanation"
                   fi
                done
        done
}
trim_single_property() {
        local attr="$1"; shift
        local over="$1"; shift

        echo -n "TRIM ${attr} -${over}>  "
        if ! with_field_value def/over "${over}" "${attr}" ""     coherently --reuse-cache ${attr} "${over}" override_builder ${attr} ${over}
        then echo "FAILED"
        elif has def/meta "${over}.explanation" "${attr}"
        then echo "OK-BUT, explanation exists:  nh x emit_explanation ${over} ${attr}"
        else echo "OK: $(get ${SUCCTY} ${over} ${attr})"
        fi
}
trim_one() {
        local attr="$1";   shift

        echo -n "TRIM ${attr} -all>  "
        if   with_field_value def/meta "disable" "${attr}" "true" coherently --reuse-cache ${attr} "default" override_builder ${attr} "default"
        then echo "OK: $(get ${SUCCTY} default ${attr})"
        else echo "FAILED"
        fi

        for over in $(lsattrs def/over ${attr})
        do trim_single_property ${attr} ${over}
        done
}
remove() {
        local attr="$1"; shift
        local overset="${1:-$(lsattrs def/over ${attr})}"; shift
        for over in ${overset}
        do _set def/over ${over} ${attr} ""
        done
}

warn() {
        local x="$1"
        local msg="$2"
        printf "%32s: $msg\n" "$x"
}
test_suggested_by_trim() {
        local over=$1; shift
        local attr=$1; shift
        has ${SUCCTY} ${over} ${attr}
}
attrs_suggested_by_trim() {
        local attr=$1; shift
        for over in $(lsattrs def/over ${attr})
        do if test_suggested_by_trim ${over} ${attr}
           then echo ${over}
           fi
        done
}
audit_one() {
        local autofix=
        local autoonly=
        while test $# -ge 1
        do case "$1"
           in --autofix ) autofix=yes-please;;
              --autoonly ) autoonly=yes-please;;
              "--"* )     fail "$0: unknown option: $1";;
              * )         break;;
           esac
           shift
        done

        local attr="$1";   shift

	if has def/meta disable ${attr}
        then warn "${attr}" "disabled"
             return 0
        fi

        local overrides="$(lsattrs def/over ${attr})"

        ## 1. Proof of necessity exists
        local status=0
        for over in ${overrides}
        do if ! emit_explanation ${over} ${attr} >/dev/null
           then
			warn      "${attr}.${over}" "no proof:  nh x emit_explanation ${over} ${attr}"; status=1
			if test_suggested_by_trim ${over} ${attr}
			then warn "${attr}.${over}" "*** already suggested for trimming ***"
			else warn "${attr}.${over}" "retrim:    nh trim --skip-baseline ${attr}"
			fi
           fi
        done

        local repo="$(repoName ${attr})"
        if ! has def/github upstream ${repo}
        then warn ${attr} "no upstream specified"
        fi

        if echo ${overrides} | grep -w "src" >/dev/null
        then
        case $(status ${attr}) in
        hackaged | shadowed )
                ## 1. Nixpkgs ought to be behind: nixpkgs release != upstream release (should be stricter: <)
                local nixpkgs_release=$(get_nixpkgs_release ${attr})
                local upstream_release=$(get_upstream_release ${attr})
                if test -z "$nixpkgs_release" -o -z "$upstream_release"
                then
                        warn "${attr}" "release versions odd: upstream $upstream_release, nixpkgs $nixpkgs_release"
                elif V "${nixpkgs_release}" '>=' "${upstream_release}"
                then
                         warn "${attr}" "nixpkgs release not behind upstream: ${nixpkgs_release}"; status=1
                         if test -n "${autofix}"
                         then warn "NOT AUTOMATICALLY FIXABLE: remove the src override"; set -x
                              _set def/over src ${attr} ""
                              set +x
                         fi
                # else echo "${attr}: ${nixpkgs_release} < ${upstream_release}"
                fi
                # if test_shadowed ${attr} && ! has def/hackage shadow ${attr}
                # then
                #         warn "${attr}" "shadow exists, but is not taken into account:  $(shadow_name ${attr})"
                #         if test -n "${autofix}"
                #         then shadow_name=$(shadow_name ${attr})
                #              warn "AUTOMATIC FIX: adding shadow -- don't forget to regen overrides"; set -x
                #              _set def/hackage shadow ${attr} "${shadow_name}"
                #              set +x
                #         fi
                # fi
                ;;
        upstreamed )
                ## Upstreamed and unreleased:
                ## 1. internal checks: upstream and PR are specified and github user is upstream
                ## 2. upstream master is not ahead upstream override rev, version-wise
                ## 3. upstream release is not on hackage yet
                local repo="$(repoName ${attr})"
                if ! has def/github upstream ${repo}
                then
                        warn "${attr}/${repo}" "github upstream not specified"; status=1
                        if test -n "${autofix}" -a -z "${autoonly}"
                        then
                                warn "MANUAL FIX: supply missing upstream"
                                echo -n "New upstream github username for ${attr}: "
                                read upstream
                                _set def/github upstream ${attr} "${upstream}"
                        fi
                elif ! test_upstreamed ${attr}
                then
                        warn "${attr}" "github user '$(get def/github user $repo)' != upstream '$(get def/github upstream $repo)'"; status=1
                        if test -n "${autofix}"
                        then warn "NOT FIXABLE: internal consistency violation"
                        fi
                #else echo "test_upstreamed ${attr}"
                fi
                local override_rev=$(get def/github rev ${repo})
                local upstream_master_release=$(  get_upstream_release ${attr} "master")
                local upstream_override_release=$(get_upstream_release ${attr} ${override_rev})
                if V "${upstream_master_release}" '>' "${upstream_override_release}"
                then
                        if test_hackage_release "${upstream_master_release}" ${attr}
                        then
                                warn "${attr}" "upstream master: ${upstream_master_release}, upstream override: ${upstream_override_release}"; status=1
                                if test -n "${autofix}"
                                then warn "AUTOMATIC FIX: promote src override from github to hackage"
                                        promote_to_hackage ${attr} "${release}" "${upstream_master_release}"
                                fi
                        else
                                warn "${attr}" "upstream master: ${upstream_master_release}, upstream override: ${upstream_override_release} BUT upstream master's version (${upstream_master_release}) is not yet on Hackage"; status=1
                       fi
                elif hackage_ahead_of_fix ${attr}
                then
                       local release=${upstream_master_release}
                       local reldate="$(hackage_release_date ${attr} ${release})"
                       local fixstamp="$(fix_timestamp ${attr})"
                       local fixdate="$(date -d @${fixstamp})"
                       warn "${attr}" "hackage ${release} obsoletes upstream fix (version ${upstream_override_release}), committed ${fixdate} < release uploaded ${reldate}"
                       if test -n "${autofix}"
                       then warn "AUTOMATIC FIX: promote src override from github to hackage"
                               promote_to_hackage ${attr} "${release}" "${release}"
                       fi
                # else echo "${attr}: ${upstream_master_release} == ${upstream_override_release}"
                fi
		;;
        unmerged )
                ## Prefer upstream:
                ## 1. no Hackage release,
                ## 2. PR available,
                ## 3. PR not merged
                local user_release=$(get_user_release ${attr})
                local upstream_release=$(get_upstream_release ${attr})
                if test -n "${user_release}" -a "${user_release}" != "${upstream_release}"
                then
                        if test_hackage_release "${upstream_release}" ${attr}
                        then
                                warn "${attr}" "upstream: ${upstream_release}, user: ${user_release}:  nh hackage ${attr} ${upstream_release}"; status=1
                                if test -n "${autofix}"
                                then warn "AUTOMATIC FIX: promote src override from github to hackage"
                                     promote_to_hackage ${attr} "${release}" "${upstream_release}"
                                fi
                        else
                                warn "${attr}" "upstream: ${upstream_release}, user: ${user_release} BUT upstream's version (${upstream_release}) is not yet on Hackage"; status=1
                        fi
                # else echo "${attr}: ${user_release} == ${upstream_release}"
                fi
                local repo="$(repoName ${attr})"
                local pr=$(get_def def/github pr ${repo} "")
                if   test -z "${pr}"
                then
                        warn "${attr}" "no upstream PR: _set def/github pr ${repo}"; status=1
                        if test -n "${autofix}" -a -z "${autoonly}"
                        then warn "MANUAL FIX: supply missing PR #"
                             echo -n "New upstream PR # for ${attr}: "
                             read pr
                             _set def/github pr ${repo} "${pr}"
                        fi
                elif test "$(github_pr_status ${attr})" = merged
                then
                        warn "${attr}" "PR ${pr} was merged upstream"
                        if test -n "${autofix}"
                        then warn "AUTOMATIC FIX: promote src override to upstream"
                             github "$(get def/github upstream ${attr})" ${attr}
                        fi
                #else echo "${attr}: PR: $(url upstream-pull-request ${attr})"
                fi;;
        config )
                ## Proof of necessity (at the top of the file) suffices.
                true;;
        * )
                fail "$0: unhandled status '$(status ${attr})' of attribute ${attr}";;
        esac
        fi

        return $status
}

audit() {
        local skip_baseline=
        local reuse_cache=
        local reuse_overrides=
        local autofix=
        while test $# -ge 1
        do case "$1"
           in --skip-baseline )        skip_baseline="--skip-baseline";;
              --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --autofix )              autofix="--autofix";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if   test -z "${skip_baseline}"
        then baseline  ${reuse_cache} ${reuse_overrides}
        elif test -z "${reuse_overrides}"
        then overrides ${reuse_cache}
        fi

        for attr in ${ATTRSET}
        do audit_one ${autofix} ${attr} || true
        done | tee ${PKGDB}/audit.log
}

acme() {
        local reuse_cache=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        if test -z "${reuse_overrides}"
        then overrides ${reuse_cache} --emit-acme
        fi

        attr=${ACME_ATTRIBUTE}
        over="default"
        echo "-( building ACME catch-all attribute that depends on everything overridden:"
        echo "--( < ${attr}"
        echo "--( > $(ls_acme_deps | xargs echo)"
        echo "---(             logs:  nh logs ${attr} ${over}"
        echo "---(    watch it live:  nh watch  --or--  nh progress"
        echo -n "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-shell ${NIX_GHC_PACKAGE_SET} -A ${attr} ${NIX_BUILD_OPTIONS} --no-out-link --keep-going 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        status=${PIPESTATUS[0]}
        if test ${status} != 0
        then nh logs ${attr} ${over} | log_filter_progress
        fi
        return ${status}
}

baseline() {
        local reuse_cache=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if test -z "${reuse_overrides}"
        then overrides ${reuse_cache}
        fi

        echo "-( validating baseline: all PKGDB overrides applied"
        for attr in ${ATTRSET}
        do
                echo -n "--("
                if ! build --reuse-overrides ${attr} "baseline"
                then fail "broken baseline package:  ${attr}"
                fi
        done | tee ${PKGDB}/baseline.log
        return ${PIPESTATUS[0]}
}

cabal2shell() {
        # ATEXIT_REMOVE_FILES="default.nix shell.nix overrides.nix"
	# trap atexit_remove_files EXIT
        cabal2nix . "$@" > default.nix
        emit_shell_nix   > shell.nix
        nh overrides
        nix-shell ${NIX_BUILD_OPTIONS}
}

cache() {
        local require_descs=
        local silent=
        while test $# -ge 1
        do case "$1"
           in --require-descs )        require_descs="require-descs";;
              --silent )               silent="silent";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over | xargs echo -n)"
        fi

        local ntotal=$(echo ${ATTRSET} | wc -w)
        local ndone=1
        for attr in ${ATTRSET}
        do
                if test -z "${silent}"; then echo -ne "\rGenerating override cache: $ndone/$ntotal" >&2; fi
                ndone=$((ndone+1))

                cache_gen_override_one ${attr} ${require_desc}
        done
        if test -z "${silent}"; then echo >&2; fi
}

github() {
        local attr="$1"
        local USER="$2"

        local repo=$(repoName ${attr})

        local REV="${3:-$(git ls-remote https://github.com/${USER}/${repo} HEAD | cut -f1)}"
        __EMPTY_REPO_HASH=0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5

        local HASH=$(nix-prefetch-git https://github.com/${USER}/${repo} --rev ${REV} --quiet | grep sha256 | cut -d'"' -f4 | tr -d '\n')

        if test "${HASH}" = "${__EMPTY_REPO_HASH}"
        then fail "zero repo hash.  Bad commit id?"
        fi

        _set def/github hash      $repo "${HASH}"
        _set def/github rev       $repo "${REV}"
        _set def/github user      $repo "${USER}"
        _set def/github timestamp $repo  $(commit_timestamp "${attr}" "${REV}")
        _set def/over   src "$attr" github

        cat <<EOF
- $(get def/github hash ${repo})
- https://github.com/${USER}/${repo}/commit/$(get def/github rev ${repo})

EOF
}
__EMPTY_HASH=0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5
hackage() {
        local PACKAGE="$1"
        local RELEASE="$2"
        local HASH="$(nix-prefetch-url http://hackage.haskell.org/package/${PACKAGE}-${RELEASE}.tar.gz | tr -d '\n')"

        if test "${HASH}" = "${__EMPTY_HASH}" -o -z "${HASH}"
        then fail "zero tarball hash.  Bad package name or version?"
        fi

        _set def/hackage hash    "$PACKAGE" "${HASH}"
        _set def/hackage release "$PACKAGE" "${RELEASE}"
        _set def/over    src     "$PACKAGE" hackage

        cat <<EOF
  - $(get def/hackage hash ${PACKAGE})
  - https://hackage.haskell.org/package/${PACKAGE}-${RELEASE}

EOF
}

info() {
        local attr="$1"
        local repo=$(repoName ${attr})
                   cat <<EOF
attribute '${attr}':

           target: $(if test_is_local ${attr}
                     then echo 'local overrides'
                     else echo 'nixpkgs'
                     fi)
           status: $(status  ${attr})
        overrides: $(lsattrs def/over ${attr} | xargs echo)
  nixpkgs release: $(get_nixpkgs_release ${attr})
 upstream release: $(get_upstream_release ${attr})
EOF
                   case $(status  ${attr}) in
                           hackaged | shadowed )
                   cat <<EOF
 override release: $(get def/hackage release ${attr})
EOF
                   ;;
                           upstreamed )
                   rev=$(get def/github rev ${repo})
                   cat <<EOF
         upstream: $(get def/github upstream ${repo})
     override rev: ${rev}
 override release: $(get_upstream_release ${attr} ${rev})
 upstream commits: $(url upstream-commits ${attr})
EOF
                   ;;
                           unmerged )
                   cat <<EOF
         upstream: $(get def/github upstream ${repo})
             user: $(get def/github user     ${repo})
     override rev: $(get def/github rev      ${repo})
 override release: $(get_user_release ${attr})
     pull request: $(url upstream-pull-request ${attr})
EOF
                   ;;
                   esac
                   if has def/github issue ${repo}
                   then cat <<EOF
            issue: $(url upstream-issue ${attr})
EOF
                   fi
                   cat <<EOF
             meta: $(lsattrs def/meta ${attr} | xargs echo)
EOF
                   if has def/meta erdeps ${attr}
                   then cat <<EOF
essential revdeps: $(get def/meta erdeps ${attr} | xargs echo)
EOF
                   fi
                   if test -n "$(attrs_suggested_by_trim ${attr})"
                   then cat <<EOF
 trim suggestions: $(attrs_suggested_by_trim ${attr})
EOF
                   fi
}
show() {
        local NAME="$1"

        (for ty in ${PKGDB}/*
         do
                 pushd $ty >/dev/null
                 if ls ${NAME}.* >/dev/null 2>&1
                 then
                         for field in ${NAME}.*
                         do
                                 ff="$(echo $field | sed 's/^.*\.\([^\.]*\)$/\1/')"
                                 printf "%20s: %s\n" $ff "$(cat $field)"
                         done
                 fi
                 popd >/dev/null
         done
        )
        cat <<EOF
            upstream: https://github.com/$(get def/github upstream $NAME)/$NAME
EOF
}

instantiate() {
        local reuse_cache=
        local debug=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="reuse-cache";;
              --debug )                debug="--debug"; enable_debug;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if test -z "${reuse_cache}"
        then cache
        fi
        overrides --reuse-cache ${debug}

        for attr in ${ATTRSET}
        do
                echo -n "EVAL ${attr}> "
                if ! do_instantiate ${attr}
                then fail "baseline breaks package:  ${attr}"
                fi
        done | tee ${PKGDB}/baseline.log
        return ${PIPESTATUS[0]}
}

loop_hunter() {
        local marker="infinite recursion encountered, at undefined position"
        local stdin="$(cat | evaluation_failure_attributes "\|${marker}" | grep -v '^interactive-.*-environment$' | sed 's/\([a-zA-Z0-9-]*\)-[0-9].*$/\1/')"
        if ! echo $stdin | grep -q "${marker}"
        then echo "No loops detected"; return 0
        fi

        local loop_attributes="$(echo $stdin | sed "s/${marker}//")"
        echo "Found a loop with attributes: $loop_attributes"

        cache
        for x in $loop_attributes
        do echo "EVAL +doCheck ${x}>  with_field_value def/over doCheck $x false instantiate --reuse-cache $x"
           if with_field_value def/over doCheck "$x" false instantiate --reuse-cache "$x"
           then echo "OK +doCheck> ${x}"
           else echo "FAIL +doCheck> ${x}"
           fi
        done
}

apply() {
        local nixpkgs=
        for x in "$@"
        do if test "$x" = "--nixpkgs"
           then nixpkgs="--nixpkgs"
           fi; done

        emit_overrides      --format overrides         ${nixpkgs:+--target local}   "$@"          > ${NIX_GHC_OVERRIDES}
        if test -n "${nixpkgs}"
        then emit_overrides --format configuration-ghc ${nixpkgs:+--target nixpkgs} --reuse-cache > ${GHC_CONFIG_FULL_PATH}
        fi
        cp -f ${NIX_GHC_OVERRIDES} ${PKGDB}/overrides.nix
}

trim() {
        local reuse_cache=
        local skip_baseline=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --skip-baseline )        skip_baseline="--skip-baseline";;
              --since )                since="$2"; shift;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then if test -z "${since}"
	     then echo "Full trimming requested, resetting state"
                  reset_state
                  ATTRSET="$(_ls def/over)"
	     else ATTRSET="$(_ls def/over | sed -ne "/^${since}/,$ p")"
             fi
        fi

        if   test -z "${skip_baseline}"
        then baseline ${reuse_cache}
        elif test -z "${reuse_cache}"
        then cache
        fi
        cache_copy override trim

        echo "-( trimming in progress"
        for attr in ${ATTRSET}
        do
                echo "TRIM ${attr}> "
                trim_one ${attr}
        done | tee ${PKGDB}/trim.log
        apply
}

print_command_help() {
        local width=25
        local len=$(echo -n "$1" | wc -c)
        if test ${len} -gt ${width}
        then printf "   %s\n                             %s\n" "$1" "$2"
        else printf "   %-${width}s %s\n" "$1" "$2"
        fi
        return 1
}
alias HELP='test "$1" != --help || print_command_help '
shopt -s expand_aliases
section() {
        local section_title="$1"; shift
cat <<EOF

  ${section_title}:

EOF
        for x in "$@"
        do command_dispatch "${x%% *}" --help
        done
}

print_help() {
cat <<EOF
Usage:  nh [--cls] [--trace] [--debug] SUBCMD [SUBARGS..]
EOF
        for x in "$@"
        do command_dispatch section-$x
        done
        echo
}

while test $# -ge 1
do case "$1"
   in --cls )              echo -en "\ec";;
      --trace )            set -x;;
      --help | -h )        $0 help;;
      --debug )            enable_debug
                           # Unfortunately, this cannot work in general, because of the broken 'return 1' handling:
                           shopt -s extdebug
                           trap 'errexit' ERR # trap ERR to provide an error handler whenever a command exits nonzero this is a more verbose version of set -o errexit
                           set -o errtrace    # setting errtrace allows our ERR trap handler to be propagated to functions,  expansions and subshells
                           ;;
      "--"* )              fail "$0: unknown option: $1";;
      * )                  break;;
   esac
   shift
done

command_dispatch() {

        local command="$1"; shift 2>/dev/null || true
        case "${command}" in
help | "" )        print_help general meta overman status overhigh github build nix maintain generate miscellanea;;

section-general )
section "General" ls info overview;;

ls )               HELP "ls [REGEX]"               "List all overridden attributes" || return 0
                   _ls | grep "$1" || true;;

info | show )      HELP "info ATTR"                "Overview of an attribute's PKGDB" || return 0
                   info                            "$1";;

overview )         HELP "overview"                 "List overridden attributes, grouped by status + relevant info" || return 0
                   for status in shadowed hackaged upstreamed unmerged config
                   do
                           cat <<EOF

## ${status}
##
EOF
                           for attr in $(filter test_is "$status" status)
                           do echo $attr
                              case $status in
                                hackaged | upstreamed | unmerged )
                                             upstream_release="$(get_upstream_release ${attr})"
                                             echo "  upstream: ${upstream_release}"
                                             echo "  nixpkgs: $(get_nixpkgs_release ${attr})";;
                              esac
                              case $status in
                                upstreamed ) echo "  commits: $(url upstream-commits ${attr})"
                                             echo "  hackage: $(url hackage ${attr})"
                                             echo "  last upstream release on hackage: $(iff yes no test_hackage_release ${upstream_release} ${attr})"
                                             echo "  hackage release date: $(hackage_release_date ${attr} ${upstream_release})"
                                             echo "  fix commit date: $(date -d @$(fix_timestamp ${attr}))"
                                             ;;
                                unmerged )   echo "  PR: $(url upstream-pull-request ${attr})";;
                              esac
                              trs="$(attrs_suggested_by_trim ${attr})"
                              if test -n "${trs}"
                              then echo "  trim suggestions: ${trs}"
                              fi
                           done
                   done;;

sanity-check )     # HELP "sanity-check"       "Internal consistency checking (non-audit-related)" || return 0;;
                   fail "NOT-IMPLEMENTED-BUT-SORELY-NEEDED";;

section-meta )
section "Metadata manipulation" ls-meta meta set-meta edit-meta chdir local nonlocal;;

ls-meta )          HELP "ls-meta ATTR"             "List attribute's metadata (as opposed to overrides" || return 0
                   lsattrs    def/meta  "$1";;

meta )             HELP "meta ATTR META"           "Print a single metadata entry of an attribute" || return 0
                   get        def/meta  "$2" "$1";;

set-meta )         HELP "set-meta ATTR META VAL"   "Set a single metadata entry of an attribute" || return 0
                   _set       def/meta  "$2" "$1" "$3";;

edit-meta )        HELP "edit-meta ATTR META"      "Edit the current attribute's meta value using readline" || return 0
                   edit       def/meta  "$2" "$1";;

chdir )            HELP "chdir ATTR SUBDIR"        "Change directory before build;  \"\" removes the override" || return 0
                   _set def/meta chdir       "$1" "$2"
                   apply "$1";;

local )            HELP "local ATTR"               "Mark ATTR as local: not subject for Nixpkgs GHC configuration" || return 0
                   _set def/meta local       "$1" local;;

nonlocal )         HELP "nonlocal ATTR"            "Remove marking of ATTR as local" || return 0
                   _set def/meta local       "$1" "";;

section-overman )
section "Override manipulation (low level)" \
         disable enable remove set-explanation set-erdeps ls-over get set edit \
         dontRevision check dontCheck haddock dontHaddock jailbreak dontJailbreak extraLibs;;

disable )          HELP "disable ATTR[.OVER]"     "Disable all/single overrides for an attribute" || return 0
                   attr="$1"; over="${2:+.$2}"
                   _set       def/meta disable${over} "$attr" true
                   apply "$1";;

enable )           HELP "enable ATTR[.OVER]"      "Re-enable previously disabled overrides" || return 0
                   attr="$1"; over="${2:+.$2}"
                   _set       def/meta disable${over} "$attr" ""
                   apply "$1";;

remove )           HELP "remove ATTR[.OVER]"      "Remove specified overrides" || return 0
                   attr="$1"; over="${2:+.$2}"
                   remove "${attr}" "${over}"
                   apply "${attr}";;

set-explanation )  HELP "set-explanation ATTR OVER" "Provide a manual explanation for an override's existence" || return 0
                   attr="$1"; over="$2"
		   edit "def/meta" "${over}".explanation "${attr}";;

set-erdeps )       HELP "set-erdeps ATTR 'ATTR..'" "Set attribute's essential rev-deps that must keep working" || return 0
                   attr="$1"; shift; erdeps="$*"
		   _set def/meta erdeps "${attr}" "${erdeps}";;

ls-over )          HELP "ls-over ATTR"            "List attribute's overrides" || return 0
                   lsattrs    def/over  "$1";;

get )              HELP "get ATTR OVER"           "Get an attribute's override value" || return 0
                   get        def/over  "$2" "$1";;

set )              HELP "set ATTR OVER VAL"       "Set an attribute's override value;  \"\" removes the override" || return 0
                   _set       def/over  "$2" "$1" "$3";       apply "$1";;

edit )             HELP "edit ATTR OVER"          "Edit the current attribute's value using readline" || return 0
                   edit def/over                 "$2" "$1";   apply "$1";;

dontRevision )     HELP "edit ATTR OVER"          "Edit the current attribute's value using readline" || return 0
                   _set def/over revision        "$1" "null"
                   _set def/over editedCabalFile "$1" "null"; apply "$1";;

check | doCheck )  HELP "check ATTR"              "Disable an existing dontCheck override" || return 0
                   _set def/over doCheck         "$1";        apply "$1";;

dontCheck )        HELP "dontCheck ATTR"          "Disable tests" || return 0
                   _set def/over doCheck         "$1" false;  apply "$1";;

haddock | doHaddock )
                   HELP "haddock ATTR"            "Disable an existing dontHaddock override" || return 0
                   _set def/over doHaddock       "$1";        apply "$1";;

dontHaddock )      HELP "dontHaddock ATTR"        "Disable Haddock generation" || return 0
                   _set def/over doHaddock       "$1" false;  apply "$1";;

jailbreak | doJailbreak )
                   HELP "jailbreak ATTR"          "Turn on jailbreaking" || return 0
                   _set def/over jailbreak       "$1" true;   apply "$1";;

dontJailbreak )    HELP "dontJailbreak ATTR"      "Disable an existing jailbreak override" || return 0
                   _set def/over jailbreak       "$1";        apply "$1";;

extraLibs )        HELP "extraLibs ATTR '[ .. ]'" \
                                                  "Specify extra dependencies;  \"\" removes the override" || return 0
                   _set def/over extraLibs       "$1" "$2";   apply "$1";;

section-status )
section "Attribute status classification" status ls-shadowed ls-hackaged ls-upstreamed ls-unmerged ls-config;;

status )           HELP "status ATTR"            "Print status of a single attribute" || return 0
                   echo "$1: $(status $1)";;

ls-shadowed )      HELP "ls-shadowed"            "List all attributes with status 'shadowed'" || return 0
                   filter test_is shadowed   status;;

ls-hackaged )      HELP "ls-hackaged"            "                             ...'hackaged'" || return 0
                   filter test_is hackaged   status;;

ls-upstreamed )    HELP "ls-upstreamed"          "                             ...'upstreamed'" || return 0
                   filter test_is upstreamed status;;

ls-unmerged )      HELP "ls-unmerged"            "                             ...'unmerged'" || return 0
                   filter test_is unmerged   status;;

ls-config )        HELP "ls-config"              "                             ...'config'" || return 0
                   filter test_is config     status;;

section-overhigh )
section "Override manipulation (high-level)" hackage unmerged upstream;;

hackage )	   HELP "hackage ATTR [RELEASE=upstream-latest]" "Set the source override to a Hackage release" || return 0
                   attr="$1"; release="${2:-$(get_upstream_release ${attr})}"
                   hackage "$attr" "$release"
                   apply "$attr";;

unmerged )	   HELP "unmerged ATTR USER PR# [REV=HEAD]"      "Set the source override to a 3rd-party Github commit" || return 0
                   attr="$1"; user="$2"; pr="$3"; rev="$4"
                   test -n "$attr" -a -n "$user" -a -n "pr" ||
                           fail "Usage: $0 unmerged ATTR GH-USER PR-ID [GITREV]"
                   github "$attr" "$user" "$rev"
                   _set def/github pr "$(repoName "$attr")" "$pr"
                   apply "$attr";;

upstream )	   HELP "upstream ATTR [REV=HEAD]"               "Set the source override to an upstream Github commit" || return 0
                   attr="$1"; rev="$2"
                   repo=$(repoName ${attr})
                   user=$(get def/github upstream $repo)
                   github "$attr" "$user" "$rev"
                   apply "$attr";;

section-github )
section "Github-based (unmerged/upstream) override manipulation" github-up set-upstream set-pr set-issue set-repoName;;

github-up )        HELP "github-up ATTR"                         "Bump a Github override to its latest HEAD" || return 0
                   attr="$1"; repo=$(repoName ${attr})
                   github "$repo" "$(get def/github user $repo)"
                   apply "$attr";;

set-upstream )     HELP "set-upstream ATTR GITHUB-USER"          "Specify an attribute's Github upstream username" || return 0
                   attr="$1"; upstream="$2"
                   _set def/github upstream $(repoName "$attr") "$upstream"
                   apply "$attr";;

set-pr )           HELP "set-pr ATTR PR#"                        "Set the PR# of an attribute's Github override" || return 0
                   attr="$1"; pr="$2"
                   if test_is unmerged status "$attr"
                   then _set def/github pr "$(repoName "$attr")" "$pr"
                   else fail "not unmerged: $attr"
                   fi
                   apply "$attr";;

set-issue )        HELP "set-issue ATTR ISSUE#"                  "Set the Issue# of an attribute's Github override" || return 0
                   attr="$1"; issue="$2"
                   _set def/github issue "$(repoName "$attr")" "$issue"
                   apply "$attr";;

set-repoName )     HELP "set-repoName ATTR REPO"                 "Set an attribute's Github repository name" || return 0
                   attr="$1"; repo="$2";     _set def/meta repoName "$attr" "$repo"
                   apply "$attr";;

section-build )
section "Build & results" build log fail failure-type failure-log expression proof;;

build )            HELP "build [COMMON-OPTS] ATTR"          "Build a single attribute" || return 0
                   build "$@";;

log | logs )       HELP "log ATTR [OVER=baseline]"          "Obtain trim build logs for a single override" || return 0
                   attr="$1"; over="${2:-baseline}"; get ${LOGTY}      "${over}" ${attr};;

fail | failure )   HELP "failure ATTR [OVER=baseline]"      "Obtain trim failure kind of an override" || return 0
                   attr="$1"; over="${2:-baseline}"; get ${FAILTY}     "${over}" ${attr};;

faillog | failure-log )
                   HELP "failure-log ATTR [OVER=baseline]"  "Obtain trim failure log of an override" || return 0
                   attr="$1"; over="$2";             faillog           "${over}" "${attr}";;

failty | failure-type )
                   HELP "failure-type ATTR [OVER=baseline]" "Obtain trim failure type of an override" || return 0
                   attr="$1"; over="${2:-baseline}"; get ${FAILTYTY}   "${over}" ${attr};;

expr | expression )
                   HELP "expression ATTR [OVER=baseline]"   "See the the expression defining an override's trim" || return 0
                   attr="$1"; over="${2:-baseline}"
                   if test "${over}" = baseline
		   then cat ${PKGDB}/build/expr/baseline  | less --pattern=" ${attr} = "
		   else get ${EXPRTY}   "${over}" ${attr} | less --pattern=" ${attr} = "
		   fi;;

proof )            HELP "proof ATTR [OVER]" "Print an override's proof of necessity. When OVER is empty, print context." || return 0
                   attr="$1"; over="$2";
                   emit_explanation "${over}" "${attr}";;

section-nix )
section "Nix-level inferences" drv src dependencies referrers;;

drv )              HELP "drv ATTR"                          "Store derivation for a single override" || return 0
                   attr="$1"; over="${2:-baseline}"
                   do_instantiate ${attr};;

src )              HELP "src ATTR"                          "Store source derivation for a single override" || return 0
                   attr="$1"; over="${2:-baseline}"
                   do_instantiate ${attr} | xargs nix-store --query --binding src;;

deps | dependencies | refs | references )
                   HELP "deps | refs | references ATTR"     "Store dependencies of an override" || return 0
                   attr="$1"; over="${2:-baseline}"
                   do_instantiate ${attr} | xargs nix-store --query --references;;

rdeps | referrers )
                   HELP "rdeps | referrers ATTR"            "Store reverse dependencies of an override" || return 0
                   attr="$1"; over="${2:-baseline}"
                   do_instantiate ${attr} | xargs nix-store --query --referrers;;

section-maintain )
section "Override database maintenance" instantiate acme baseline trim trim-single show-trims execute-trims audit extra-validation-attributes;;

instantiate )      HELP "instantiate [--reuse-cache] [ATTR..]" "Instantiate overridden attrs (or specified subset)" || return 0
                   instantiate "$@";;

acme )
                   HELP "acme [--reuse-cache]" "Build everything at once, collecting all failures" || return 0
                   acme "$@";;

baseline )         HELP "baseline [--reuse-{overrides,cache}] [ATTR..]" "Build overridden attrs (or specified subset)" || return 0
                   baseline "$@";;

trim )             HELP "trim [--skip-baseline] [--reuse-cache] [ATTR..]" \
                           "Suggest a reduction to the override set (or specified subset)" || return 0
                   trim "$@";;

trim-single )      HELP "trim-single ATTR OVER" "Attempt trimming a specific override of a given attribute" || return 0
                   trim_single_property "$@";;

show-trims )       HELP "show-trims" "Show the trim suggestion" || return 0
                   show_trims "$@";;

execute-trims )    HELP "execute-trims" "Execute the suggestion" || return 0
                   execute_trims "$@"
                   apply;;

audit )            HELP "audit [--autofix] [--autoonly] [--skip-baseline] [--reuse-{overrides,cache}] [ATTR]" \
                           "Sanity check the overridden attrs (or specified subset).  --autofix applies suggestions" || return 0
                   audit "$@";;

extra-validation-attributes )
                   HELP "extra-validation-attributes" "Edit the set of attributes validated regardless of being overridden" || return 0
                   edit def/meta extra-validation-attributes "";;

section-generate )
section "Generation of overrides" over apply cache show-cache;;

over | override | show-override )
                   HELP "over | override | show-override ATTR" \
                           "Print the attribute's override defined by PKGDB" || return 0
                   emit_override "$1";;

apply | overrides )
                   HELP "apply [--reuse-cache] [--nixpkgs]" \
                           "Apply all overrides via ${NIX_GHC_OVERRIDES}.  If --nixpkgs is passed, non-local overrides instead serve as definition for ${GHC_CONFIG_FULL_PATH}" || return 0
                   apply "$@";;

cache )            HELP "cache [--require-descs]" \
                           "Regenerate override cache" || return 0
                   cache "$@";;

show-cache )       HELP "show-cache ATTR"      "Print the cached text of attribute's override (DEBUG)" || return 0
                   get cache override "$1";;

section-miscellanea )
section "Miscellanea" eval shell cabal2shell shell-failures loop-hunter progress watch;;

eval | x )         HELP "eval 'BASH-EXPR'"     "Passthrough, to execute anything defined." || return 0
                   "$@";;

shell )            HELP "shell"                "Nix shell with up-to-date overrides (shell.nix required)" || return 0
                   apply "$@"
                   nix-shell --max-jobs 4 --cores 0 --keep-going;;

cabal2shell )      HELP "cabal2shell"          "Nix shell from a cabal file (nothing else required)" || return 0
                   cabal2shell "$@";;

shell-failures )   HELP "shell-failures"       "Entering nix-shell, filtering the build log for failures" || return 0
                   build_log="${1:-shell-failures.log}"; shift
                   apply "$@"
                   nix-shell --max-jobs 4 --cores 0 --keep-going 2>&1 | tee ${build_log} |
                               log_filter_progress;;

loop-hunter )      HELP "loop-hunter"          "Detect attribute loops:  nix-shell 2>&1 | nh loop-hunter" || return 0
                   loop_hunter;;

progress )         HELP "progress"             "Observe build progress" || return 0
                   if   test -f "$(cat ${PKGDB}/current.build    2>/dev/null)"
                   then      log=$(cat ${PKGDB}/current.build    2>/dev/null)
                   else fail "Nothing to watch, exiting."
                   fi
                   echo "watching ${log}"
                   nlines=$(stty size | awk '{print $1}')
                   watch --interval=1 --no-title bash -c "'cat $(cat ${PKGDB}/current.build    2>/dev/null) | nh x log_filter_progress' | tail -n$((nlines-1))";;

watch )            HELP "watch"                "Observe the current build, as it hits the logs.." || return 0
                   if   test -f "$(cat ${PKGDB}/current.build    2>/dev/null)"
                   then      log=$(cat ${PKGDB}/current.build    2>/dev/null)
                   else fail "Nothing to watch, exiting."
                   fi
                   echo "watching $log"
                   tail -f "$log";;

www )              # HELP "www URL-KIND ATTR"     "Elinks -> an URL associated with ATTR" || return 0
                   kind="$1"; name="$1"; elinks "$(url $kind $name)";;

 * )		   fail "unknown command '${command}'";;
esac
}

command_dispatch "$@"
