#+TITLE: nh: Nix Haskell package management
#+PROPERTY: header-args :tangle nh :tangle-mode (identity #o755)

* Header
#+begin_src sh
#!/usr/bin/env bash

set -e

if test -n "${NH_DEBUG}"
then set -x
fi
DEFAULT_GHC=841  ## The value is actually configured, so this is for the absolute defaults.

#+end_src
* Library
*** Basis
  #+begin_src sh
backtrace() {
  if [ ${#FUNCNAME[@]} -gt 2 ]
  then
    echo "Backtrace:" >&2
    for ((i=1;i<${#FUNCNAME[@]}-1;i++))
    do
      echo " $i: ${BASH_SOURCE[$i+1]}:${BASH_LINENO[$i]} ${FUNCNAME[$i]} ${BASH_ARGV[$i+1]}" >&2
    done
  fi
}
errexit() {
  local err=$?
  set +o xtrace
  local code="${1:-1}"
  echo "Error in ${BASH_SOURCE[1]}:${BASH_LINENO[0]}. '${BASH_COMMAND}' exited with status $err" >&2
  # Print out the stack trace described by $function_stack
  backtrace
  exit "${code}"
}
fail() { echo "FATAL: $*" >&2; backtrace; exit 1;
       }
fail_untraced() { echo "FATAL: $*" >&2; exit 1;
       }
when() { local pred="$1"; shift; if test -n "${pred}"; then "$@"; fi
       }
  #+end_src
*** Ensure config and PKGDB exist
#+BEGIN_SRC sh
init_pkgdb() {
        dir="$1"
        force="$2"

        if   test -e "${dir}" -a "${force}" != "--force"
        then fail "cannot make a new override database at '${dir}': already exists"
        elif test -z "${dir}"
        then fail "override DB location not specified"
        fi

        mkdir -p ${dir}/def/{over,meta,github,hackage}
        mkdir -p ${dir}/cache
        mkdir -p ${dir}/build/{log,drv,expr,src,success,failure{,-type,-log}}
        rm -f ${dir}/def/{over,meta,github,hackage}/*
        rm -f ${dir}/cache/*
        rm -f ${dir}/build/{log,drv,expr,src,success,failure{,-type,-log}}/*
        exit 0
}
validate_pkgdb() {
        pkgdb="$1"
        test    -d ${pkgdb}/def/over    \
             -a -d ${pkgdb}/def/meta    \
             -a -d ${pkgdb}/def/github  \
             -a -d ${pkgdb}/def/hackage \
             -a -d ${pkgdb}/cache       \
             -a -d ${pkgdb}/build
}
# Simulate disjoint types
LOGTY=build/log
DRVTY=build/drv
EXPRTY=build/expr
SRCTY=build/src
SUCCTY=build/success
FAILTY=build/failure
FAILTYTY=build/failure-type
FAILLOGTY=build/failure-log

emit_nh_config() {
        PKGDB="$1"
        cat <<EOF
GHC=${DEFAULT_GHC}
PKGDB=${PKGDB}  # The override state database.
NIX_GHC_OVERRIDES=overrides.nix        # The job of 'nh' is to help you maintain this.
NIX_GHC_PACKAGE_SET=packages.nix       # Define a proper GHC package set.
EOF
}

emit_packages_nix() {
        cat <<EOF
{ nixpkgs     ? import <nixpkgs> {}
, pkgs        ? nixpkgs.pkgs, haskell ? pkgs.haskell
, compiler    ? "ghc${DEFAULT_GHC}"
, ghcOrig     ? pkgs.haskell.packages."\${compiler}"
}:

ghcOrig.override (oldArgs: {
    overrides = new: old:
    import ./overrides.nix { inherit pkgs; self = new; super = old; haskellLib = haskell.lib; };
  })
EOF
}

emit_shell_nix() {
        cat <<EOF
{ nixpkgs     ? import <nixpkgs> {}
, pkgs        ? nixpkgs.pkgs, haskell ? pkgs.haskell
, compiler    ? "ghc${GHC}"
, ghcOrig     ? pkgs.haskell.packages."\${compiler}"
, tools       ? false
, intero      ? tools
}:
let

  ghc     = import ./packages.nix { inherit nixpkgs pkgs haskell compiler ghcOrig; };
  default = import ./.;
  drv     = ghc.callPackage default {};
  drv'    = haskell.lib.overrideCabal
            drv
            (old: {
              libraryHaskellDepends =
                old.libraryHaskellDepends
                ++ [ pkgs.cabal-install ];
             });
in
  drv'.env
EOF
}

if   test -f .nh
then true
elif test "$1" = "--auto-init"
then shift
     emit_nh_config      "pkgdb" > .nh
     emit_packages_nix           > packages.nix
     if ! validate_pkgdb "pkgdb"
     then init_pkgdb     "pkgdb" --force
     fi
else cat << EOF
ERROR: the .nh configuration file is not present in the working directory.

Consider the following:  cat > .nh

$(emit_nh_config /home/user/configuration-ghc84x)

Don't have packages.nix?  cat > packages.nix

$(emit_packages_nix)

EOF
     exit 1
fi

source .nh

if test "$1" = "init"
then shift; init_pkgdb "$@"; fi

if test -z "${PKGDB}" || ! validate_pkgdb "${PKGDB}"
then fail_untraced ".nh doesn't define PKGDB to point to a valid package database."; fi

if test -z "${NIX_GHC_PACKAGE_SET}"  -o ! -r ${NIX_GHC_PACKAGE_SET}
then fail_untraced ".nh doesn't define NIX_GHC_PACKAGE_SET to point to a readable file."; fi

NIXPKGS="$(nix-instantiate --eval -E '<nixpkgs>')"
if test $? != 0 -o -z "$NIXPKGS"
then fail "Unable to find Nixpkgs:  nix-instantiate --eval -E '<nixpkgs>'"
fi

if ! type nix-prefetch-git >/dev/null
then fail "missing tool:  nix-prefetch-git   (fix: nix-env -i nix-prefetch-scripts)"
fi

NIX_BUILD_OPTIONS="--argstr compiler ghc${GHC} --show-trace --cores 0"
#+END_SRC
*** Functional
    #+BEGIN_SRC sh
cons_by() {
        local attr="$1"; shift

        echo -n "${attr} "
        "$@" ${attr}
}
test_is() {
        local VALUE="$1"; shift
        test "$($*)" = "${VALUE}"
}
map() {
        local ACTION="$1"; shift
        for x in "$@"
        do ${ACTION} "$x"
        done
}
map1() {
        local ACTION="$1"; shift
        local ARG1="$1";  shift
        for x in "$@"
        do ${ACTION} "${ARG1}" "$x"
        done
}
map2() {
        local ACTION="$1"; shift
        local ARG1="$1";  shift
        local ARG2="$1";  shift
        for x in "$@"
        do ${ACTION} "${ARG1}" "${ARG2}" "$x"
        done
}
    #+END_SRC
*** PKGDB operations
    #+BEGIN_SRC sh
path() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"

        echo ${PKGDB}/${TYPE}/${NAME}.${FIELD}
}
_ls() {
        local TYPE="${1:-def/over}"

        pushd ${PKGDB}/${TYPE} >/dev/null

        case $TYPE in
                def/github | def/hackage )                 ls -1 *.${2:-hash} 2>/dev/null | sed "s/\\.${2:-hash}//";;
                def/over | build/success | build/failure ) ls -1 *            2>/dev/null | grep -v "\\.baseline$" | sed 's/^\(.*\)\.[^\.]*$/\1/' | sort | uniq;;
                * ) echo "FATAL: listing of '${TYPE}' is not supported" >&2; popd; return 1;;
        esac | sort
        popd >/dev/null
}
lsattrs() {
        local TYPE="$1"; shift
        local NAME="$1"; shift

        pushd ${PKGDB}/${TYPE} >/dev/null
        ls -1 * 2>/dev/null | grep "^$NAME\\." | grep -v "\\.baseline$" | sed 's/^[^\.]*\.\(.*\)$/\1/'
        popd >/dev/null
}
get() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"

        if test -f ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        then   cat ${PKGDB}/${TYPE}/${NAME}.${FIELD} 2>/dev/null
        else return 1
        fi
}
get_def() {
        local DEFAULT="$4"

        get "$1" "$2" "$3" || echo -n "$DEFAULT"
}
has() {
        test -f $(path "$@")
}
_set() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"
        local VALUE="$4"

        if test -z "${VALUE}"
        then rm -f ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        else echo -n "${VALUE}" > ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        fi
}
set_stdin() {
        local TYPE="$1"
        local FIELD="$2"
        local NAME="$3"

        cat > ${PKGDB}/${TYPE}/${NAME}.${FIELD}
}
    #+END_SRC
*** Selection
    #+BEGIN_SRC sh
by() {
        local TYPE="$1"
        local FIELD="$2"
        local VALUE="$3"
        shift 3

        for x in $(_ls ${TYPE})
        do if test "$(get ${TYPE} ${FIELD} $x)" = "${VALUE}"
           then echo $x
           fi
        done
}
    #+END_SRC
*** Pure queries
    #+BEGIN_SRC sh
attrName() {
        local attr="$1"; shift
        get_def def/meta attrName ${attr} "${attr}"
}
repoName() {
        local attr="$1"; shift
        get_def def/meta repoName ${attr} "${attr}"
}
shadow_name() {
        local attr="$1";        shift
        has def/hackage release ${attr} &&
                echo "${attr}_$(get def/hackage release ${attr} | sed 's/\./_/g')"
}
shadows() {
        local attr="$1";        shift
        local nixpkgs="${2:-/home/deepfire/src/nixpkgs}"

        local hackage_packages=${NIXPKGS}/pkgs/development/haskell-modules/hackage-packages.nix

        if test ! -f "${hackage_packages}"
        then echo "FATAL: ${nixpkgs} doesn't point to a valid Nixpkgs checkout"; return 1
        fi

        grep "${attr}_.* = callPackage" ${hackage_packages} | cut -d'"' -f2
}
test_upstreamed() {
        local repo="$(repoName $1)"
        local upstream="$(get def/github upstream $repo)"
        local user="$(get def/github user $repo)"

        test -n "${user}" -a "${user}" = "${upstream}"
}
test_shadow_exists() {
        local attr="$1";        shift

        local shadow=$(shadow_name ${attr} || true)
        test "$(get def/over src $attr)" = "hackage" -a -n "$shadow" && { shadows ${attr} | grep -q "$shadow"; }
}
test_shadowed() {
        local attr="$1";        shift

        test_shadow_exists "${attr}" && ! has def/meta suppress-shadow "${attr}" ## XXX: re-use the 'disable' mechanism
}
    #+END_SRC
*** Log filtering
#+BEGIN_SRC sh
log_filter_failure() {
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        grep '^builder for.*failed with exit code 1' | sed 's|.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|\1|'
}
log_filter_success() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        grep '^checking for references to.* in /nix/store/.*\.\.\.' | sed 's|.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|\1|'
}
log_filter_result() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        grep --line-buffered '^builder for.*failed with exit code 1\|^checking for references to.* in /nix/store/.*[0-9]\.\.\.' | sed 's|^builder for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|FAIL: \1|' | sed 's|checking for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|OK: \1|'
}
log_filter_progress() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        # setupCompileFlags: -package-db=/tmp/nix-build-hedgehog-0.5.1.drv-0/package.conf.d -j8 -threaded
        grep --line-buffered '^builder for.*failed with exit code 1\|^checking for references to.* in /nix/store/.*[0-9]\.\.\.\|setupCompileFlags: -package-db=/tmp/nix-build-.*' | sed 's|^builder for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|FAIL: \1|' | sed 's|checking for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|OK:   \1|' | sed 's|setupCompileFlags: -package-db=/tmp/nix-build-\([a-zA-Z0-9-]*\)-[0-9].*$|NEW:  \1|'
}
#+END_SRC
*** Nix
    #+BEGIN_SRC sh
drv_src() {
        local over="$1";        shift
        local attr="$1";        shift
        nix-store --query --binding src ${PKGDB}/${DRVTY}/${attr}.${over}
}
evaluation_failure_attributes() {
        local grep_extra="$1"
        grep "while evaluating the attribute${grep_extra}" | sed 's/.*derivation ‘\(.*\)’ at.*/\1/'
}
do_instantiate() {
        local attr="$1"; shift

        if !    nix-instantiate ${NIX_GHC_PACKAGE_SET} -A ${attr} --argstr compiler ghc${GHC} 2>/dev/null
        then
                echo "FATAL:  failed to instantiate ${attr}, the repro is:" >&2
                echo "FATAL:  nix-instantiate ${NIX_GHC_PACKAGE_SET} -A ${attr} --argstr compiler ghc${GHC} --show-trace" >&2
                nix-instantiate ${NIX_GHC_PACKAGE_SET} -A ${attr} --argstr compiler ghc${GHC} --show-trace
                exit 1
        fi
}
nreferrers() {
        local attr="$1"

        local drv=$(do_instantiate ${attr})
        local refs=$(nix-store --query --referrers-closure ${drv} | wc -l)
        echo ${refs} ${attr} ${drv}
}
    #+END_SRC
*** State
***** Mass manipulation
      #+BEGIN_SRC sh
reset_state() {
        mkdir -p ${PKGDB}/{${LOGTY},${DRVTY},${EXPRTY},${SRCTY},${SUCCTY},${FAILTY},${FAILTYTY},${FAILLOGTY}}
        rm -f    ${PKGDB}/{${LOGTY},${DRVTY},${EXPRTY},${SRCTY},${SUCCTY},${FAILTY},${FAILTYTY},${FAILLOGTY}}/* 2>/dev/null ||
                true
}
edit() {
        local TYPE="$1";  shift
        local FIELD="$1"; shift
        local NAME="$1";  shift

        read -ep "${NAME}.${TYPE}.${FIELD}: " -i "$(get ${TYPE} ${FIELD} ${NAME})"
        _set "${TYPE}" "${FIELD}" ${NAME} "${REPLY}"
}
stdin_forall_edit() {
        local TYPE="$1";  shift
        local FIELD="$1"; shift

        for name in $*
        do
                read -p "${TYPE}.${FIELD} for ${name}: "
                _set "${TYPE}" "${FIELD}" ${name} "${REPLY}"
        done
}
stdin_forall_set() {
        local TYPE="$1"
        local FIELD="$2"
        local VALUE="$3"

        for name in $(cat)
        do _set "${TYPE}" "${FIELD}" ${name} "${VALUE}"
        done
}
      #+END_SRC
***** Queries
      #+BEGIN_SRC sh
filter() {
        for attr in $(_ls)
        do if "$@" ${attr} > /dev/null
           then echo ${attr}
           fi
        done
}
overset_config() {
        (
                _ls def/over
                by  def/over src hackage
                by  def/over src github
        ) | sort | uniq -u
}
lstopo() {
        local TYPE="$1"

        local ntotal=$(_ls ${TYPE} | wc -l)
        local ndone=1
        for attr in $(_ls ${TYPE})
        do
                echo -ne "\rComputing topology order: $ndone/$ntotal" >&2
                ndone=$((ndone+1))

                nreferrers ${attr}
        done | sort -nr
        echo >&2
}
get_nixpkgs_release() {
        local attr="$1"; shift

        nix-instantiate --eval -E "(import <nixpkgs> {}).pkgs.haskell.packages.ghc${GHC}.${attr}.version" | xargs echo -n
}
status() {
        local attr="$1"

        case $(get_def def/over src ${attr} maybe-config) in
        hackage ) if test_shadowed "$1"
                  then echo -n "shadowed"
                  else echo -n "hackaged"
                  fi;;
        github  ) if test_upstreamed "$1"
                  then echo -n "upstreamed"
                  else echo -n "unmerged"
                  fi;;
        maybe-config )
                  if test -n "$(lsattrs def/over $1)"
		  then echo -n "config"
		  else echo -n "default"
                  fi;;
        * )       echo "FATAL: invalid status for '${attr}': '$(get def/over src ${attr})'";;
        esac
}
      #+END_SRC
***** Logs
      #+BEGIN_SRC sh
get_log() {
        local over="$1"; shift
        local attr="$1"; shift

        get ${LOGTY} ${over} ${attr}
}
faillog() {
        local over="$1"
        local attr="$2"

        test "$(get ${FAILTYTY} ${over} ${attr})" != UNKNOWN || {
                echo "WARNING: failure type UNKNOWN for:  ${attr}.${over}" >&2
                return 1
        }

	set +e
        get ${FAILLOGTY} ${over} ${attr}.prebuild
        local status0=$?
        get ${FAILLOGTY} ${over} ${attr}
        local status1=$?
	set -e

        test $status0 = 0 -o $status1 = 0
}
      #+END_SRC
*** Classification
    #+BEGIN_SRC sh
declare -A sig grepctx
sig["CABAL-MISSING-DEPS"]="Setup: Encountered missing dependencies"
sig["HASKELL-SMP-NO-INSTANCE-FOR"]="No instance for \(Semigroup"
sig["HASKELL-SMP-COULD-NOT-DEDUCE"]="Could not deduce \(Semigroup"
sig["HASKELL-SMP-APPEND-CONFLICT"]="Ambiguous occurrence ‘<>’"
sig["HASKELL-SMP-NO-INSTANCE-IMPL-FOR"]="No instance nor default method for class operation <>"
sig["HASKELL-SMP-VERSION"]="Module ‘Data.Semigroup’ does not export ‘"
sig["GHC-BUG"]="Please report this as a GHC bug"
sig["CABAL-NOT-FOUND"]="/bin/sh: cabal: command not found"
sig["NO-SUCH-FILE-OR-DIRECTORY"]=": No such file or directory"
sig["NIX-ERROR-EVAL-OVERRIDECABAL"]="error: while evaluating ‘overrideCabal’"
sig["JAILBREAK-CABAL-MISSING-CABAL"]="jailbreak-cabal: dieVerbatim: user error \(jailbreak-cabal: Error Parsing: file "
sig["CABAL-CONFIGURE-MISSING-PROGRAM"]="Setup: The program '[A-Za-z-]*' is required but it could not be found"
sig["NIX-MISSING-ATTRIBUTE"]="error: attribute ‘[A-Za-z-]*’ in selection path ‘[A-Za-z-]*’ not found"
sig["HASKELL-MISSING-EXPORT"]="Module ‘[A-Za-z-]*’ does not export ‘"
sig["HASKELL-AMBIGUOUS-TYPE-VARIABLE-ERROR"]="Ambiguous type variable"
sig["HASKELL-TYPE-ERROR"]="Couldn't match expected type"
sig["HASKELL-MISSING-INSTANCE"]="No instance for \("
sig["HASKELL-CONTEXT-NOT-SATISFIED"]="Could not deduce \("
sig["HASKELL-MISSING-MODULE"]="Could not find module ‘"
sig["HASKELL-VAR-NOT-IN-SCOPE"]="Variable not in scope:"
sig["CURL-404"]="The requested URL returned error: 404 Not Found"
sig["NO-SUCH-FILE-OR-DIRECTORY"]="No such file or directory"
sig["NO-CABAL-FILE-FOUND"]="Setup: No cabal file found"
sig["TH-RUNTIME-EXCEPTION"]="Exception when trying to run compile-time code:"

grepctx["CABAL-MISSING-DEPS"]="-A5"
grepctx["HASKELL-SMP-NO-INSTANCE-FOR"]="-A2"
grepctx["HASKELL-SMP-COULD-NOT-DEDUCE"]="-A2"
grepctx["HASKELL-SMP-APPEND-CONFLICT"]="-A2"
grepctx["HASKELL-SMP-VERSION"]="-A2"
grepctx["GHC-BUG"]="-B30"
grepctx["HASKELL-TYPE-ERROR"]="-A3"
grepctx["HASKELL-MISSING-INSTANCE"]="-A2"
grepctx["HASKELL-CONTEXT-NOT-SATISFIED"]="-A2"
grepctx["CURL-404"]="-A1"
grepctx["TH-RUNTIME-EXCEPTION"]="-B1 -A7"

fail_classify_one_property() {
        local over="$1";      shift
        local attr="$1";      shift
        local no_state_change="$1"

        for i in "${!sig[@]}"
        do if      get_log ${over} ${attr} | egrep --max-count=1                  "${sig[$i]}" >/dev/null 2>&1
           then
                   echo ${i}
                   if test -z "${no_state_change}"
                   then _set ${FAILTYTY} ${over} ${attr} "$i"
                   fi
                   get_log ${over} ${attr} | egrep --max-count=1 ${grepctx["$i"]} "${sig[$i]}" \
			| grep -v "^$\|^builder for ‘/nix/store/\|^error: build of ‘/nix/store/" |
                           { if test -n "${no_state_change}"
                             then cat
                             else tee $(path ${FAILLOGTY} ${over} ${attr})
                             fi; }
                   return 0
           fi
        done
        echo UNKNOWN
        _set ${FAILTYTY} ${over} ${attr} UNKNOWN
        return 1
}
    #+END_SRC
*** Network
***** url
      #+BEGIN_SRC sh
url() {
        local KIND="$1"; shift
        local attr="$1"; shift

        local subpath=
        local gitrev=master
        local release=
        while test $# -ge 1
        do case "$1"
           in --subpath )              subpath="$2"; shift;;
              --gitrev )               gitrev="$2";  shift;;
              --release )              release="$2"; shift;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )     break;;
           esac
           shift
        done

        local repo="$(repoName "$attr")"
        case "${KIND}" in
                upstream-github-cabal )      echo -n "https://raw.githubusercontent.com/$(get def/github upstream $repo)/$repo/${gitrev}/$subpath$attr.cabal";;
                user-github-cabal )          echo -n "https://raw.githubusercontent.com/$(get def/github user     $repo)/$repo/${gitrev}/$subpath$attr.cabal";;
                upstream-github )            echo -n "https://github.com/$(               get def/github upstream $repo)/$repo";;
                upstream-pull-request )      echo -n "https://github.com/$(               get def/github upstream $repo)/$repo/pull/$(get def/github pr $repo)";;
                commits | upstream-commits ) echo -n "https://github.com/$(               get def/github upstream $repo)/$repo/commits/master";;
                user-commits )               echo -n "https://github.com/$(               get def/github user     $repo)/$repo/commits/master";;
                github-prs )                 echo -n "https://github.com/$(               get def/github upstream $repo)/$repo/pulls";;
                hackage )                    echo -n "https://hackage.haskell.org/package/$attr";;
                hackage-package )            echo -n "https://hackage.haskell.org/package/$attr-$release/$attr-$release.tar.gz";;
                * ) fail "invalid URL kind: '$KIND'";;
        esac
}
      #+END_SRC
***** fetch-cabal
      #+BEGIN_SRC sh
fetch_cabal() {
        local kind="$1"; shift
        local attr="$1"; shift
        local gitrev="${1:-master}"
        local chdir="$(get_def def/over chdir $attr $(get_def def/meta chdir $attr ''))"

        curl -sL $(url ${kind}-github-cabal $(attrName ${attr}) --subpath "${chdir}${chdir:+/}" --gitrev "${gitrev}")
}
      #+END_SRC
***** upstream-release, user-release
      #+BEGIN_SRC sh
get_upstream_release() {
        local attr="$1"
        local gitrev="${2:-master}"
        fetch_cabal upstream ${attr} ${gitrev} | grep -i '^version:' | sed 's/[vV]ersion:[ ]*//'
}
get_user_release() {
        local attr="$1"
        local gitrev="${2:-master}"
        fetch_cabal user ${attr} ${gitrev} | grep -i '^version:' | sed 's/[vV]ersion:[ ]*//'
}
      #+END_SRC
***** test-hackage-release
      #+BEGIN_SRC sh
test_hackage_release() {
        local release="$1"; shift
        local attr="$1"; shift

        local url="$(url hackage-package ${attr} --release ${release})"

        curl -sI "${url}" | grep -q 'HTTP/1.1 200 OK'
}
      #+END_SRC
***** github-pr-status
#+BEGIN_SRC sh
github_pr_status() {
        local attr="$1"
        local repo="$(repoName "$attr")"
        local user="$(get def/github user ${repo})"
        local pull_request="$(get_def def/github pr ${repo} '')"

        if test -z "${pull_request}"
        then echo "FATAL:  pull-request not specified for github repo '${repo}'" >&2
             fail " logs:  get def/github pr ${repo}"
        fi

        local http_code="$(curl -sI https://api.github.com/repos/${user}/${repo}/pulls/${pull_request}/merge | grep 'HTTP/1.1')"

        if   echo "${http_code}" | grep -q "204 No Content"
        then echo -n "merged"
        elif echo "${http_code}" | grep -q "404 Not Found"
        then echo -n "unmerged"
        else return 1
        fi
}
#+END_SRC
*** Emission
    #+BEGIN_SRC sh
emit_explanation() {
        local over="$1"; shift
        local attr="$1"; shift

        if test "${over}" = src
        then case $(status ${attr}) in
                     shadowed   ) echo "Needs bump to a versioned attribute";;
                     hackaged   ) echo "On Hackage, awaiting for import";;
                     upstreamed ) echo "Upstreamed, awaiting a Hackage release";;
                     unmerged   ) echo "Unmerged.  PR: $(url upstream-pull-request ${attr})";;
             esac
             echo
        fi
        get def/meta ${over}.explanation ${attr} ||
                faillog ${over} ${attr}
}
emit_src_description() {
        local attr="$1";         shift

        case "$(get def/over src ${attr})" in
                hackage )    echo "    ## Hackage import needed";;
                github )
                        if test_upstreamed "${attr}"
                        then echo "    ## Fixes upstreamed, awaiting Hackage release"
                        else echo "    ## Fixes not upstream yet"
                        fi;;
        esac
}
fail_uncached() {
        echo -e "\nFATAL: attribute $1 has no override cache" >&2
        exit 1
}
emit_property_override() {
        attr="$1"; shift
        propName="$1"
        eval "${propName}=\"$(get_def def/over ${propName} ${attr})\""
        eval propVal=\$$propName
        if test ! -z "${propVal}" && ! has def/meta disable.${propName} ${attr}
        then
                emit_explanation ${propName} ${attr} | sed 's/^/    ## /'
                if test ! -z "${REQUIRE_DESC}" -a ${PIPESTATUS[0]} != 0
                then fail "missing failure log for ${attr}.${propName}, and couldn't compute it either:  nh x emit_explanation ${propName} ${attr}"
                fi
                case "${propName}" in
                        src )
                                case "$src" in
                                        hackage )
                                                if ! test_shadowed "${attr}"
                                                then
                                                cat <<EOF
    version         = "$(get def/hackage release ${attr})";
    sha256          = "$(get def/hackage hash    ${attr})";
EOF
                                                fi
                                                ;;
                                        github )
                                                repo=$(repoName ${attr})
                                                cat <<EOF
    src = pkgs.fetchFromGitHub {
      owner  = "$(get def/github user ${repo})";
      repo   = "${repo}";
      rev    = "$(get def/github rev  ${repo})";
      sha256 = "$(get def/github hash ${repo})";
    };
EOF
                                                ;;
                                        * )     fail "unknown value for src override: '$src'";;
                                esac;;
                        doCheck )          echo "    doCheck         = ${doCheck};";;
                        doHaddock )        echo "    doHaddock       = ${doHaddock};";;
                        jailbreak )        echo "    jailbreak       = ${jailbreak};";;
                        editedCabalFile )  echo "    editedCabalFile = ${editedCabalFile};";;
                        revision )         echo "    revision        = ${revision};";;
                        chdir )            echo "    prePatch        = \"cd ${chdir}; \";";;
                        postPatch )        echo "    postPatch       = \"${postPatch}\";";;
                        extraLibs )        echo "    libraryHaskellDepends = drv.libraryHaskellDepends ++ ${extraLibs};";;
                        * ) fail "unknown property: '${propName}'";;
                esac
        fi
}
emit_override() {
        local attr="$1"
        local base_attr=""

        if test -z "$(lsattrs def/over ${attr})" ||   has def/meta disable     "${attr}"
        then return
        fi
        if test_shadowed "${attr}"               && ! has def/meta disable.src "${attr}"
	then shadowed=yes; base_attr="$(shadow_name ${attr})"
        else shadowed=;    base_attr="${attr}"
        fi
        if test -n "${shadowed}" && test "$(lsattrs def/over ${attr} | xargs echo -n)" = "src"
        then
                emit_explanation src ${attr} | sed 's/^/  ## /'
                cat <<EOF
  ${attr} = super.${base_attr};

EOF
        else
                cat <<EOF
  ${attr} = overrideCabal super.${base_attr} (drv: {
EOF
                props="src doCheck doHaddock jailbreak editedCabalFile revision chdir postPatch extraLibs"
                for p in ${props}
                do emit_property_override ${attr} $p
                done
                cat <<EOF
  });

EOF
        fi
}
emit_overrides() {
        local reuse_cache=
        local require_descs=
        local silent=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --require-descs )        require_descs="--require-descs";;
              --silent )               silent="--silent";;
              --debug )                set -x;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        ###
        ### 1. Generate override cache
        ###
        if test -z "${reuse_cache}"
        then
                cache_drop override
                cache ${require_descs} ${silent} ||
                        fail "cache generation failed" >&2
        fi

        echo -n "Assembling overrides.." >&2
        ###
        ### 2. Emit overrides
        ###

        cat <<EOF
{ pkgs, haskellLib, super, self }:

with haskellLib; with self; {

  ## Shadowed:

EOF
        for attr in $(filter test_is shadowed status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## On Hackage:

EOF
        for attr in $(filter test_is hackaged status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## Upstreamed

EOF
        for attr in $(filter test_is upstreamed status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## Unmerged

EOF
        for attr in $(filter test_is unmerged status)
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF

  ## Non-code, configuration-only change

EOF
        for attr in $(overset_config) ## same as filter test_is config status', but faster
        do get cache override ${attr} || fail_uncached ${attr}; echo -n . >&2
        done

        cat <<EOF
}
EOF
        echo " done." >&2
}
    #+END_SRC
*** Cache
***** cache-gen-override-one
      #+BEGIN_SRC sh
cache_gen_override_one() {
        local attr="$1"
        local REQUIRE_DESC="$2"

        emit_override ${attr} "${REQUIRE_DESC}" | set_stdin cache override ${attr}
        if test ${PIPESTATUS[0]} != 0
        then fail "failed to compute override for ${attr}"
        fi
}
      #+END_SRC
***** coherently
#+BEGIN_SRC sh
coherently() {
        local reuse_cache=
        local reuse_overrides=
        local require_desc=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --require-desc )         require_desc="--require-desc";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local attr=$1; shift
        local over=$1; shift

        emit_override ${attr} ${require_desc} | set_stdin cache override ${attr}
        if test ${PIPESTATUS[0]} != 0
        then fail "failed to compute override ${attr}"
        fi
        get cache override ${attr}

	# Record the overall expression used.
        if test ${over} = "baseline"
        then if test -z "${reuse_overrides}"
             then emit_overrides ${reuse_cache} | tee ${PKGDB}/${EXPRTY}/baseline        > ${NIX_GHC_OVERRIDES}
             else cp -f ${NIX_GHC_OVERRIDES}          ${PKGDB}/${EXPRTY}/baseline
             fi
        else      emit_overrides ${reuse_cache} | tee ${PKGDB}/${EXPRTY}/${attr}.${over} > ${NIX_GHC_OVERRIDES}
        fi

        "$@"
}
cache_copy() {
        local FIELD_FROM="$1"; shift
        local FIELD_TO="$1";   shift

        pushd ${PKGDB}/cache >/dev/null
        for from in *.${FIELD_FROM}
        do
                to="$(echo $from | sed 's/^\(.*\)\.[^\.]*$/\1/')".${FIELD_TO}
                cp -f "${from}" "${to}"
        done
	popd >/dev/null
}
cache_drop() {
        FIELD="$1"
        rm -f ${PKGDB}/cache/*.${FIELD}
}
    #+END_SRC
*** Building
***** override-builder
#+BEGIN_SRC sh
override_builder() {
        while test $# -ge 1
        do case "$1"
           in "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local attr="$1"; shift
        local over="$1"; shift

        ###
        ### 1. Instantiate
        ###
        local store_drv="$(do_instantiate ${attr})"
	local status=$?
	if test ${status} = 0 -a -n "${store_drv}"
	then
	        rm -f            ${PKGDB}/${DRVTY}/${attr}.${over}
	        ln -s $store_drv ${PKGDB}/${DRVTY}/${attr}.${over}
        	local store_src="$(drv_src ${over} ${attr})"
	        rm -f            ${PKGDB}/${SRCTY}/${attr}.${over}
	        ln -s $store_src ${PKGDB}/${SRCTY}/${attr}.${over}
	else
		{ do_instantiate ${attr} 2>&1 || true; } |
    			set_stdin          ${LOGTY} ${over} ${attr}
                echo "FATAL: failed to instantiate '${attr}', without overriding '${over}'" >&2
                echo "FATAL: logs:  nh get ${LOGTY} ${over} ${attr}" >&2
                _set ${FAILTYTY} ${over} ${attr} "INSTANTIATE"
                _set ${FAILTY}   ${over} ${attr} "INSTANTIATE"
		## TODO:  invoke the loop hunter?
                return 1
	fi

        ###
        ### 2. prebuild context
        ###
        echo -n      "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-shell ${NIX_GHC_PACKAGE_SET} -A ${attr} ${NIX_BUILD_OPTIONS} --no-out-link 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        local status=${PIPESTATUS[0]}
        if test ${status} != 0
        then
                echo "FATAL: failed to prebuild deps of '${attr}', without overriding '${over}'" >&2
                intermediate_failure=$(get ${LOGTY} "${over}" ${attr} | log_filter_failure)
		if test -n "${intermediate_failure}"
		then
                	echo "FATAL: ..apparently due to:  ${intermediate_failure}"
                	echo "FATAL: logs:  nh get ${LOGTY} ${over} ${attr}" >&2
		fi
                _set ${FAILTY}   ${over} ${attr} "DEPENDENCY/${intermediate_failure:-UNKNOWN}"
                fail_classify_one_property ${over} ${attr}
                return 1
        fi

        ###
        ### 3. build
        ###
        echo -n      "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-build ${NIX_GHC_PACKAGE_SET} -A ${attr} ${NIX_BUILD_OPTIONS} 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        status=${PIPESTATUS[0]}
        rm -f ${PKGDB}/current.build
        if test ${status} = 0
        then
                _set ${SUCCTY} ${over} ${attr} $(readlink result)
                rm -f result
                _set ${FAILTY}    ${over} ${attr} ""
                _set ${FAILLOGTY} ${over} ${attr} ""
                _set ${FAILTYTY}  ${over} ${attr} ""
        else
                echo "FATAL: failed to build '${attr}', without overriding '${over}'" >&2
                echo "FATAL: logs:  nh get ${LOGTY} ${over} ${attr}" >&2
                _set ${FAILTY}   ${over} ${attr} "DIRECT"
                fail_classify_one_property ${over} ${attr}
        fi

        return $status
}
#+END_SRC
***** with-field-value
      #+BEGIN_SRC sh
WFV_TYPE=
WFV_FIELD=
WFV_NAME=
WFV_SAVE_VAL=
with_field_value_atexit() {
        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${WFV_SAVE_VAL}"
        cache_gen_override_one "${WFV_NAME}"
}
with_field_value() {
        update_cache=
        while test $# -ge 1
        do case "$1"
           in --debug )                set -x;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        WFV_TYPE="$1";    shift
        WFV_FIELD="$1";   shift
        WFV_NAME="$1";    shift
        local value="$1"; shift

        WFV_SAVE_VAL="$(get_def ${WFV_TYPE} ${WFV_FIELD} ${WFV_NAME} '')"
        # test ! -z "${SAVE_VAL}" || {
        #         echo "FATAL: '${OVER}' isn't specified for attribute  '${ATTR}'"
        #         exit 1
        # }

        trap with_field_value_atexit EXIT

        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${value}"
        cache_gen_override_one "${WFV_NAME}"

        "$@"
        result=$?
        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${WFV_SAVE_VAL}"
        cache_gen_override_one "${WFV_NAME}"
        return $result
}
      #+END_SRC
***** build
      #+BEGIN_SRC sh
build() {
        reuse_cache=
        reuse_overrides=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --debug )                set -x;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done
        local attr=$1; shift
        local over=${1:-baseline}

        coherently ${reuse_cache} ${reuse_overrides} ${attr} "${over}" override_builder ${attr} "${over}"
}
      #+END_SRC
*** Trimming
#+BEGIN_SRC sh
execute_trim() {
        for attr in $(_ls ${SUCCTY})
        do
                trimset="$(lsattrs ${SUCCTY} ${attr} | xargs echo -n)"
                if test "${trimset}" = "default"
                then
                        echo "--( ${attr} now entirely redundant"
                        trimset="$(lsattrs def/over ${attr} | xargs echo -n)"
                fi

                echo "--( ${attr} trimmable: ${trimset}"
                for over in ${trimset}
                do if ! has  def/meta ${over}.explanation ${attr}
                   then _set def/over ${over} ${attr} ""
                   else echo "---( keeping ${over}, since it has an explanation"
                   fi
                done
        done
}
trim_one() {
        local attr="$1";   shift

        echo -n "TRIM ${attr} -all>  "
        if    with_field_value def/meta         "disable" "${attr}" "true" coherently --reuse-cache ${attr} "default" override_builder ${attr} "default"
        then echo "OK: $(get ${SUCCTY} default ${attr})"
        else echo "FAILED"
        fi

        for over in $(lsattrs def/over ${attr})
        do echo -n "TRIM ${attr} -${over}>  "
           if has def/meta "${over}.explanation" "${attr}"
           then echo "SKIPPED, explanation exists:  nh x emit_explanation ${over} ${attr}"
           elif with_field_value def/over "${over}" "${attr}" ""     coherently --reuse-cache ${attr} "${over}" override_builder ${attr} ${over}
           then echo "OK: $(get ${SUCCTY} ${over} ${attr})"
           else echo "FAILED"
           fi
        done
}
#+END_SRC
*** Audit
    #+BEGIN_SRC sh
warn() {
        x="$1"
        msg="$2"
        printf "%32s: $msg\n" "$x"
}

promote_to_hackage() {
        attr="$1"
        release="$2"
        upstream_master_release="$3"

        if test_hackage_release "${upstream_master_release}" ${attr}
        then hackage ${attr} "${upstream_master_release}"
        else warn "AUTOMATIC FIX STALLED: github release version (${upstream_master_release}) has not been put on Hackage yet"
             echo -n "New Hackage release for ${attr}: "
             read release
             hackage ${attr} "${release}"
        fi
}
function V() # $1-a $2-op $3-$b
# Author: stepse@StackOverflow: https://stackoverflow.com/a/48487783
# Compare a and b as version strings. Rules:
# R1: a and b : dot-separated sequence of items. Items are numeric. The last item can optionally end with letters, i.e., 2.5 or 2.5a.
# R2: Zeros are automatically inserted to compare the same number of items, i.e., 1.0 < 1.0.1 means 1.0.0 < 1.0.1 => yes.
# R3: op can be '=' '==' '!=' '<' '<=' '>' '>=' (lexicographic).
# R4: Unrestricted number of digits of any item, i.e., 3.0003 > 3.0000004.
# R5: Unrestricted number of items.
{
  local a=$1 op=$2 b=$3 al=${1##*.} bl=${3##*.}
  while [[ $al =~ ^[[:digit:]] ]]; do al=${al:1}; done
  while [[ $bl =~ ^[[:digit:]] ]]; do bl=${bl:1}; done
  local ai=${a%$al} bi=${b%$bl}

  local ap=${ai//[[:digit:]]} bp=${bi//[[:digit:]]}
  ap=${ap//./.0} bp=${bp//./.0}

  local w=1 fmt=$a.$b x IFS=.
  for x in $fmt; do [ ${#x} -gt $w ] && w=${#x}; done
  fmt=${*//[^.]}; fmt=${fmt//./%${w}s}
  printf -v a $fmt $ai$bp; printf -v a "%s-%${w}s" $a $al
  printf -v b $fmt $bi$ap; printf -v b "%s-%${w}s" $b $bl

  case $op in
    '<='|'>=' ) [ "$a" ${op:0:1} "$b" ] || [ "$a" = "$b" ] ;;
    * )         [ "$a" $op "$b" ] ;;
  esac
}
audit_one() {
        local autofix=
        while test $# -ge 1
        do case "$1"
           in --autofix ) autofix=yes-please;;
              "--"* )     fail "$0: unknown option: $1";;
              * )         break;;
           esac
           shift
        done

        local attr="$1";   shift

        local overrides="$(lsattrs def/over ${attr})"

        ## 1. Proof of necessity exists
        local status=0
        for over in ${overrides}
        do if ! emit_explanation ${over} ${attr} >/dev/null
           then
			warn      "${attr}.${over}" "no proof:  nh x emit_explanation ${over} ${attr}"; status=1
			if has ${SUCCTY} ${over} ${attr}
			then warn "${attr}.${over}" "*** already suggested for trimming ***"
			else warn "${attr}.${over}" "retrim:    nh trim --skip-baseline ${attr}"
			fi
           fi
        done

        local repo="$(repoName ${attr})"
        if ! has def/github upstream ${repo}
        then warn ${attr} "no upstream specified"
        fi

        if echo ${overrides} | grep -w "src" >/dev/null
        then
        case $(status ${attr}) in
        hackaged | shadowed )
                ## 1. Nixpkgs ought to be behind: nixpkgs release != upstream release (should be stricter: <)
                local nixpkgs_release=$(get_nixpkgs_release ${attr})
                local upstream_release=$(get_upstream_release ${attr})
                if test -z "$nixpkgs_release" -o -z "$upstream_release"
                then
                        warn "${attr}" "release versions odd: upstream $upstream_release, nixpkgs $nixpkgs_release"
                elif V "${nixpkgs_release}" '>=' "${upstream_release}"
                then
                         warn "${attr}" "nixpkgs release not behind upstream: ${nixpkgs_release}"; status=1
                         if test -n "${autofix}"
                         then warn "NOT AUTOMATICALLY FIXABLE: remove the src override"; set -x
                              _set def/over src ${attr} ""
                              set +x
                         fi
                # else echo "${attr}: ${nixpkgs_release} < ${upstream_release}"
                fi
                # if test_shadowed ${attr} && ! has def/hackage shadow ${attr}
                # then
                #         warn "${attr}" "shadow exists, but is not taken into account:  $(shadow_name ${attr})"
                #         if test -n "${autofix}"
                #         then shadow_name=$(shadow_name ${attr})
                #              warn "AUTOMATIC FIX: adding shadow -- don't forget to regen overrides"; set -x
                #              _set def/hackage shadow ${attr} "${shadow_name}"
                #              set +x
                #         fi
                # fi
                ;;
        upstreamed )
                ## Upstreamed and unreleased:
                ## 1. internal checks: upstream is specified and github user is upstream
                ## 2. upstream master is not ahead upstream override rev, version-wise
                ## 3. upstream release is not on hackage yet
                local repo="$(repoName ${attr})"
                if ! has def/github upstream ${repo}
                then
                        warn "${attr}/${repo}" "github upstream not specified"; status=1
                        if test -n "${autofix}"
                        then
                                warn "MANUAL FIX: supply missing upstream"
                                echo -n "New upstream github username for ${attr}: "
                                read upstream
                                _set def/github upstream ${attr} "${upstream}"
                        fi
                elif ! test_upstreamed ${attr}
                then
                        warn "${attr}" "github user '$(get def/github user $repo)' != upstream '$(get def/github upstream $repo)'"; status=1
                        if test -n "${autofix}"
                        then warn "NOT FIXABLE: internal consistency violation"
                        fi
                #else echo "test_upstreamed ${attr}"
                fi
                local override_rev=$(get def/github rev ${repo})
                local upstream_master_release=$(  get_upstream_release ${attr} "master")
                local upstream_override_release=$(get_upstream_release ${attr} ${override_rev})
                if V "${upstream_master_release}" '>' "${upstream_override_release}"
                then
                        if test_hackage_release "${upstream_master_release}" ${attr}
                        then
                                warn "${attr}" "upstream master: ${upstream_master_release}, upstream override: ${upstream_override_release}"; status=1
                                if test -n "${autofix}"
                                then warn "AUTOMATIC FIX: promote src override from github to hackage"
                                        promote_to_hackage ${attr} "${release}" "${upstream_master_release}"
                                fi
                        else
                                warn "${attr}" "upstream master: ${upstream_master_release}, upstream override: ${upstream_override_release} BUT upstream master's version (${upstream_master_release}) is not yet on Hackage"; status=1
                       fi
                # else echo "${attr}: ${upstream_master_release} == ${upstream_override_release}"
                fi
		;;
        unmerged )
                ## Prefer upstream:
                ## 1. no Hackage release,
                ## 2. PR available,
                ## 3. PR not merged
                local user_release=$(get_user_release ${attr})
                local upstream_release=$(get_upstream_release ${attr})
                if test -n "${user_release}" -a "${user_release}" != "${upstream_release}"
                then
                        if test_hackage_release "${upstream_release}" ${attr}
                        then
                                warn "${attr}" "upstream: ${upstream_release}, user: ${user_release}:  nh hackage ${attr} ${upstream_release}"; status=1
                                if test -n "${autofix}"
                                then warn "AUTOMATIC FIX: promote src override from github to hackage"
                                     promote_to_hackage ${attr} "${release}" "${upstream_release}"
                                fi
                        else
                                warn "${attr}" "upstream: ${upstream_release}, user: ${user_release} BUT upstream's version (${upstream_release}) is not yet on Hackage"; status=1
                        fi
                # else echo "${attr}: ${user_release} == ${upstream_release}"
                fi
                local repo="$(repoName ${attr})"
                local pr=$(get_def def/github pr ${repo} "")
                if   test -z "${pr}"
                then
                        warn "${attr}" "no PR: _set def/github pr ${repo}"; status=1
                        if test -n "${autofix}"
                        then warn "MANUAL FIX: supply missing PR #"
                             echo -n "New upstream PR # for ${attr}: "
                             read pr
                             _set def/github pr ${repo} "${pr}"
                        fi
                elif test "$(github_pr_status ${attr})" = merged
                then
                        warn "${attr}" "PR ${pr} was merged upstream"
                        if test -n "${autofix}"
                        then warn "AUTOMATIC FIX: promote src override to upstream"
                             github "$(get def/github upstream ${attr})" ${attr}
                        fi
                #else echo "${attr}: PR: $(url upstream-pull-request ${attr})"
                fi;;
        config )
                ## Proof of necessity (at the top of the file) suffices.
                true;;
        * )
                fail "$0: unhandled status '$(status ${attr})' of attribute ${attr}";;
        esac
        fi

        return $status
}
#+END_SRC
*** Commands
***** audit
#+BEGIN_SRC sh
audit() {
        local skip_baseline=
        local reuse_cache=
        local reuse_overrides=
        local autofix=
        while test $# -ge 1
        do case "$1"
           in --skip-baseline )        skip_baseline="--skip-baseline";;
              --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --autofix )              autofix="--autofix";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if   test -z "${skip_baseline}"
        then baseline  ${reuse_cache} ${reuse_overrides}
        elif test -z "${reuse_overrides}"
        then overrides ${reuse_cache}
        fi

        for attr in ${ATTRSET}
        do audit_one ${autofix} ${attr} || true
        done | tee ${PKGDB}/audit.log
}
#+END_SRC
***** baseline
#+BEGIN_SRC sh
baseline() {
        local reuse_cache=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if test -z "${reuse_overrides}"
        then overrides ${reuse_cache}
        fi

        echo "-( validating baseline: all PKGDB overrides applied"
        for attr in ${ATTRSET}
        do
                echo "--( ${attr}"
                if ! build --reuse-overrides ${attr} "baseline"
                then fail "broken baseline package:  ${attr}"
                fi
        done | tee ${PKGDB}/baseline.log
        return ${PIPESTATUS[0]}
}
#+END_SRC
***** cache
#+BEGIN_SRC sh
cache() {
        local require_descs=
        local silent=
        while test $# -ge 1
        do case "$1"
           in --require-descs )        require_descs="require-descs";;
              --silent )               silent="silent";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over | xargs echo -n)"
        fi

        local ntotal=$(echo ${ATTRSET} | wc -w)
        local ndone=1
        for attr in ${ATTRSET}
        do
                if test -z "${silent}"; then echo -ne "\rGenerating override cache: $ndone/$ntotal" >&2; fi
                ndone=$((ndone+1))

                cache_gen_override_one ${attr} ${require_desc}
        done
        if test -z "${silent}"; then echo >&2; fi
}
#+END_SRC
***** instantiate
      #+BEGIN_SRC sh
instantiate() {
        local reuse_cache=
        local debug=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="reuse-cache";;
              --debug )                debug="--debug"; set -x;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if test -z "${reuse_cache}"
        then cache
        fi
        overrides --reuse-cache ${debug}

        for attr in ${ATTRSET}
        do
                echo -n "EVAL ${attr}> "
                if ! do_instantiate ${attr}
                then fail "baseline breaks package:  ${attr}"
                fi
        done | tee ${PKGDB}/baseline.log
        return ${PIPESTATUS[0]}
}
      #+END_SRC
***** github & hackage
      #+BEGIN_SRC sh
github() {
        local attr="$1"
        local USER="$2"

        local repo=$(repoName ${attr})

        local REV="${3:-$(git ls-remote https://github.com/${USER}/${repo} HEAD | cut -f1)}"
        __EMPTY_REPO_HASH=0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5

        local HASH=$(nix-prefetch-git https://github.com/${USER}/${repo} --rev ${REV} --quiet | grep sha256 | cut -d'"' -f4 | tr -d '\n')

        if test "${HASH}" = "${__EMPTY_REPO_HASH}"
        then fail "zero repo hash.  Bad commit id?"
        fi

        _set def/github hash $repo "${HASH}"
        _set def/github rev  $repo "${REV}"
        _set def/github user $repo "${USER}"
        _set def/over   src "$attr" github

        cat <<EOF
- $(get def/github hash ${repo})
- https://github.com/${USER}/${repo}/commit/$(get def/github rev ${repo})

EOF
}
__EMPTY_HASH=0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5
hackage() {
        local PACKAGE="$1"
        local RELEASE="$2"
        local HASH="$(nix-prefetch-url http://hackage.haskell.org/package/${PACKAGE}-${RELEASE}.tar.gz | tr -d '\n')"

        if test "${HASH}" = "${__EMPTY_HASH}" -o -z "${HASH}"
        then fail "zero tarball hash.  Bad package name or version?"
        fi

        _set def/hackage hash    "$PACKAGE" "${HASH}"
        _set def/hackage release "$PACKAGE" "${RELEASE}"
        _set def/over    src     "$PACKAGE" hackage

        cat <<EOF
  - $(get def/hackage hash ${PACKAGE})
  - https://hackage.haskell.org/package/${PACKAGE}-${RELEASE}

EOF
}
      #+END_SRC
***** info
      #+BEGIN_SRC sh
info() {
        local attr="$1"
        local repo=$(repoName ${attr})
                   cat <<EOF
attribute '${attr}':

           status: $(status  ${attr})
        overrides: $(lsattrs def/over ${attr} | xargs echo)
  nixpkgs release: $(get_nixpkgs_release ${attr})
 upstream release: $(get_upstream_release ${attr})
EOF
                   case $(status  ${attr}) in
                           hackaged | hackaged )
                   cat <<EOF
      release (o): $(get def/hackage release ${attr})
EOF
                   ;;
                           upstreamed )
                   cat <<EOF
         upstream: $(get def/github upstream ${repo})
         rev (ov): $(get def/github rev      ${repo})
 upstream commits: $(url upstream-commits ${attr})
EOF
                   ;;
                           unmerged )
                   cat <<EOF
         upstream: $(get def/github upstream ${repo})
             user: $(get def/github user     ${repo})
         rev (ov): $(get def/github rev      ${repo})
     user release: $(get_upstream_release ${attr})
     pull request: $(url upstream-pull-request ${attr})
EOF
                   ;;
                   esac
                   cat <<EOF
             meta: $(lsattrs def/meta ${attr} | xargs echo)
EOF
}
show() {
        local NAME="$1"

        (for ty in ${PKGDB}/*
         do
                 pushd $ty >/dev/null
                 if ls ${NAME}.* >/dev/null 2>&1
                 then
                         for field in ${NAME}.*
                         do
                                 ff="$(echo $field | sed 's/^.*\.\([^\.]*\)$/\1/')"
                                 printf "%20s: %s\n" $ff "$(cat $field)"
                         done
                 fi
                 popd >/dev/null
         done
        )
        cat <<EOF
            upstream: https://github.com/$(get def/github upstream $NAME)/$NAME
EOF
}
      #+END_SRC
***** loop-hunter
#+BEGIN_SRC sh
loop_hunter() {
        local marker="infinite recursion encountered, at undefined position"
        local stdin="$(cat | evaluation_failure_attributes "\|${marker}" | grep -v '^interactive-.*-environment$' | sed 's/\([a-zA-Z0-9-]*\)-[0-9].*$/\1/')"
        if ! echo $stdin | grep -q "${marker}"
        then echo "No loops detected"; return 0
        fi

        local loop_attributes="$(echo $stdin | sed "s/${marker}//")"
        echo "Found a loop with attributes: $loop_attributes"

        cache
        for x in $loop_attributes
        do echo "EVAL +doCheck ${x}>  with_field_value def/over doCheck $x false instantiate --reuse-cache $x"
           if with_field_value def/over doCheck "$x" false instantiate --reuse-cache "$x"
           then echo "OK +doCheck> ${x}"
           else echo "FAIL +doCheck> ${x}"
           fi
        done
}
#+END_SRC
***** overrides
#+BEGIN_SRC sh
overrides() {
        emit_overrides "$@" > ${NIX_GHC_OVERRIDES}
}
#+END_SRC
***** trim
#+BEGIN_SRC sh
trim() {
        local reuse_cache=
        local skip_baseline=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --skip-baseline )        skip_baseline="--skip-baseline";;
              --since )                since="$2"; shift;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then if test -z "${since}"
	     then echo "Full trimming requested, resetting state"
                  reset_state
                  ATTRSET="$(_ls def/over)"
	     else ATTRSET="$(_ls def/over | sed -ne "/^${since}/,$ p")"
             fi
        fi

        if   test -z "${skip_baseline}"
        then baseline ${reuse_cache}
        elif test -z "${reuse_cache}"
        then cache
        fi
        cache_copy override trim

        echo "-( trimming in progress"
        for attr in ${ATTRSET}
        do
                echo "TRIM ${attr}> "
                trim_one ${attr}
        done | tee ${PKGDB}/trim.log
}
#+END_SRC
*** Misc cleanup routines
  #+begin_src sh
ATEXIT_REMOVE_FILES=
atexit_remove_files() {
	rm -f ${ATEXIT_REMOVE_FILES}
}
  #+END_SRC
* Utilities
#+begin_src sh
cabal2shell() {
        # ATEXIT_REMOVE_FILES="default.nix shell.nix overrides.nix"
	# trap atexit_remove_files EXIT
        cabal2nix . "$@" > default.nix
        emit_shell_nix   > shell.nix
        nh overrides
        nix-shell ${NIX_BUILD_OPTIONS}
}
#+END_SRC
* Argument parsing
#+begin_src sh
while test $# -ge 1
do case "$1"
   in --cls )              echo -en "\ec";;
      --trace )            set -x;;
      --debug )            set -x
                           # Unfortunately, this cannot work in general, because of the broken 'return 1' handling:
                           shopt -s extdebug
                           trap 'errexit' ERR # trap ERR to provide an error handler whenever a command exits nonzero this is a more verbose version of set -o errexit
                           set -o errtrace    # setting errtrace allows our ERR trap handler to be propagated to functions,  expansions and subshells
                           ;;
      "--"* )              fail "$0: unknown option: $1";;
      * )                  break;;
   esac
   shift
done

#+end_src
* Top level dispatch
#+begin_src sh
command="$1"; shift 2>/dev/null || true
case "${command}" in
info | show )      info                            "$1";;      ## Overview of an attribute's PKGDB
show-override | override | over )
                   emit_override "$1";;                        ## Print the override defined by PKGDB
show-cache )       get cache override "$1";;                   ## Print the cached override value
sanity-check )     ## For internal consistency checking (non-audit-related).
                   fail "NOT-IMPLEMENTED-BUT-SORELY-NEEDED";;
explain )          attr="$1"; over="$2";
                   emit_explanation "${over}" "${attr}";;

## Meta manupulation:                                          ## List/get/set non-directly-overriding properties
ls-meta )          lsattrs    def/meta  "$1";;
meta )             get        def/meta  "$2" "$1";;
set-meta )         _set       def/meta  "$2" "$1" "$3";;

## Override manipulation (low-level):
disable )          attr="$1"; over="${2:+.$2}"
                   _set       def/meta disable${over} "$attr" true  ## Disable all/single overrides for an attribute
                   cache_gen_override_one "$1";;
enable )           attr="$1"; over="${2:+.$2}"
                   _set       def/meta disable${over} "$attr" ""    ## Re-enable previously disabled overrides
                   cache_gen_override_one "$1";;                    ## List/get/set/edit overrides
ls )               lsattrs    def/over  "$1";;
get )              get        def/over  "$2" "$1";;
set )              _set       def/over  "$2" "$1" "$3"
                   cache_gen_override_one "$1";;
edit )             edit                      "$1" "$2" "$3";;

## src override type query:                                    ## Overrides carry one of the five status values:
status )           echo "$1: $(status $1)";;
ls-shadowed )      filter test_is shadowed   status;;
ls-hackaged )      filter test_is hackaged   status;;
ls-upstreamed )    filter test_is upstreamed status;;
ls-unmerged )      filter test_is unmerged   status;;
ls-config )        filter test_is config     status;;

## Override manipulation (high-level):
hackage )	   attr="$1"; release="$2";        hackage "$attr" "$release"
                   cache_gen_override_one "$attr";;
hackage-up )       attr="$1";                      hackage "$attr" "$(get_upstream_release ${attr})"
                   cache_gen_override_one "$attr";;
unmerged )	   attr="$1"; user="$2"; pr="$3"; rev="$4"
                   test -n "$attr" -a -n "$user" -a -n "pr" ||
                           fail "Usage: $0 unmerged ATTR GH-USER PR-ID [GITREV]"
                   github "$attr" "$user" "$rev"
                   _set def/github pr "$(repoName "$attr")" "$pr"
                   cache_gen_override_one "$attr";;
upstream )	   attr="$1"; rev="$2"; repo=$(repoName ${attr})
                   github "$repo" "$(get def/github upstream $repo)" "$rev"
                   cache_gen_override_one "$attr";;
github )           attr="$1"; repo=$(repoName ${attr})
		   _set def/over src "${attr}" github
                   github "$repo" "$(get def/github upstream $repo)"
                   cache_gen_override_one "$attr";;
github-up )        attr="$1"; repo=$(repoName ${attr})
                   github "$repo" "$(get def/github user $repo)"
                   cache_gen_override_one "$attr";;
set-pr )           attr="$1"; pr="$2"
                   if test_is unmerged status "$attr"
                   then _set def/github pr "$(repoName "$attr")" "$pr"
                   else fail "not unmerged: $attr"
                   fi;                                               cache_gen_override_one "$attr";;
set-explanation )  attr="$1"; over="$2"
		   edit "def/meta" "${over}".explanation "${attr}";;
set-upstream )     attr="$1"; upstream="$2"; _set def/github upstream $(repoName "$attr") "$upstream"
                   cache_gen_override_one "$attr";;
set-repoName )     attr="$1"; repo="$2";     _set def/meta repoName "$attr" "$repo"
                   cache_gen_override_one "$attr";;
dontRevision )            _set def/over revision        "$1" "null"
                          _set def/over editedCabalFile "$1" "null"; cache_gen_override_one "$1";;
check | doCheck )         _set def/over doCheck         "$1";        cache_gen_override_one "$1";;
dontCheck )               _set def/over doCheck         "$1" false;  cache_gen_override_one "$1";;
haddock | doHaddock )     _set def/over doHaddock       "$1";        cache_gen_override_one "$1";;
dontHaddock )             _set def/over doHaddock       "$1" false;  cache_gen_override_one "$1";;
jailbreak | doJailbreak ) _set def/over jailbreak       "$1" true;   cache_gen_override_one "$1";;
dontJailbreak )           _set def/over jailbreak       "$1";        cache_gen_override_one "$1";;
chdir )                   _set def/over chdir           "$1" "$2";   cache_gen_override_one "$1";;
extraLibs )               _set def/over extraLibs       "$1" "$2";   cache_gen_override_one "$1";;

## Individual packages (high-level)
build )            build                      "$@";;     ##  Build a single package
log | logs )          attr="$1"; over="${2:-baseline}"; get ${LOGTY}    "${over}" ${attr};;
fail | failure )      attr="$1"; over="${2:-baseline}"; get ${FAILTY}   "${over}" ${attr};;
fail | failure-type ) attr="$1"; over="${2:-baseline}"; get ${FAILTYTY} "${over}" ${attr};;
expr | expression )   attr="$1"; over="${2:-baseline}"
                      if test "${over}" = baseline
		      then cat ${PKGDB}/build/expr/baseline  | less --pattern=" ${attr} = "
		      else get ${EXPRTY}   "${over}" ${attr} | less --pattern=" ${attr} = "
		      fi;;

## Override database maintenance
instantiate )      instantiate                "$@";;     ##  Instantiate overridden attrs                 (or specified subset)
baseline )         baseline                   "$@";;     ##  Build overridden attrs                       (or specified subset)
trim )             trim                       "$@";;     ##  Suggest a reduction to the override set      (or specified subset)
execute-trim )     execute_trim               "$@";;     ##  Execute the suggestion
audit )            audit                      "$@";;     ##  Perform sanity check on the overridden attrs (or specified subset)

## ${NIX_GHC_OVERRIDES} generation
cache )            if test -z "$*"; then cache_drop override; fi
                   cache "$@";;
overrides )        overrides                  "$@";;
overrides-descs )  overrides --require-descs;;

##
## Miscellanea
##
x | eval )         "$@";;                                ##  Passthrough, to execute anything defined.
shell )
                   overrides "$@"
                   nix-shell --max-jobs 4 --cores 0 --keep-going;;

cabal2shell )      ## Enter Nix shell for an environment specified with just a cabal file.
                   cabal2shell "$@";;

shell-failures )   build_log="${1:-shell-failures.log}"; shift
                   overrides                  "$@"
                   nix-shell --max-jobs 4 --cores 0 --keep-going 2>&1 | tee ${build_log} |
                               log_filter_progress;;

loop-hunter )      ## Detect attribute loops in the message stream of Nix evaluation.
                   loop_hunter;;                         ##  Use like:  nix-shell 2>&1 | nh loop-hunter

watch )            ## Observe the current build, as it goes..
                   if   test -f "$(cat ${PKGDB}/current.prebuild 2>/dev/null)"
                   then      log=$(cat ${PKGDB}/current.prebuild 2>/dev/null)
                   elif test -f "$(cat ${PKGDB}/current.build    2>/dev/null)"
                   then      log=$(cat ${PKGDB}/current.build    2>/dev/null)
                   else fail "Nothing to watch, exiting."
                   fi
                   echo "watching $log"
                   tail -f "$log"
                   ;;
www )              kind="$1"; name="$1"; elinks "$(url $kind $name)";;
 * )		   fail "unknown command '${command}'";;
esac
#+end_src

;;; Local Variables:
;;; eval: (add-hook 'after-save-hook 'org-babel-tangle)
;;; End:
