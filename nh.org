#+TITLE: nh: Nix Haskell package management
#+PROPERTY: header-args :tangle nh :tangle-mode (identity #o755)

* Header
#+begin_src sh
#!/usr/bin/env bash

set -e

DEFAULT_GHC=841  ## The value is actually configured, so this is for the absolute defaults.
DEFAULT_GHC_CONFIG=configuration-ghc-8.4.x.nix
ACME_ATTRIBUTE=nh-acme-grand-total-attribute
TARGET_NIXPKGS=
NH_QUIET=

#+end_src
* Basis
*** Failing properly
  #+begin_src sh
enable_debug() {
        set -x
        shopt -s extdebug
        NH_BACKTRACE=true
}
if test -n "${NH_DEBUG}"
then enable_debug
fi

backtrace() {
   if test -z "${NH_BACKTRACE}"
   then return 0
   fi
   ## Source: https://www.runscripts.com/support/guides/scripting/bash/debugging-bash/stack-trace
   local frame=0
   local argv_offset=0
   local caller_info=

   echo
   echo "Backtrace:" >&2
   while caller_info=( $(caller $frame) ) ; do
       declare argv=()
       local argc
       local frame_argc

       for ((frame_argc=${BASH_ARGC[frame]}, frame_argc--, argc=0; frame_argc >= 0; argc++, frame_argc--)) ; do
           argv[argc]=${BASH_ARGV[argv_offset+frame_argc]}
           case "${argv[argc]}" in
               *[[:space:]]*) argv[argc]="'${argv[argc]}'" ;;
           esac
       done
       local argv_offset=$((argv_offset + ${BASH_ARGC[frame]}))
       printf "  ${frame}: line %4d: ${FUNCNAME[frame]} ${argv[*]}\n" "${caller_info[0]}" >&2
:
       frame=$((frame+1))
   done

   if [[ $frame -eq 1 ]] ; then
       caller_info=( $(caller 0) )
       echo ":: ${caller_info[2]}: Line ${caller_info[0]}: ${caller_info[1]}" >&2
   fi
}
errexit() {
  local err=$?
  set +o xtrace
  local code="${1:-1}"
  echo "Error in ${BASH_SOURCE[1]}:${BASH_LINENO[0]}. '${BASH_COMMAND}' exited with status $err" >&2
  # Print out the stack trace described by $function_stack
  backtrace
  exit "${code}"
}
fail() { echo "FATAL: $*" >&2; backtrace; exit 1;
       }
fail_untraced() { echo "FATAL: $*" >&2; exit 1;
       }
tracing_suspendable() {
        local mode="$1"
        case "${mode}" in
                * ) test -n "${NH_TRACING}";;
        esac
}
tracing_suspend() { if tracing_suspendable "$@"; then set +x; fi
}
tracing_resume()  { if tracing_suspendable "$@"; then set -x; fi
}
  #+end_src
*** Misc cleanup routines
  #+begin_src sh
ATEXIT_REMOVE_FILES=
atexit_remove_files() {
	rm -f ${ATEXIT_REMOVE_FILES}
}
  #+END_SRC
*** Shell library
    #+BEGIN_SRC sh
cons_by() {
        local attr="$1"; shift

        echo -n "${attr} "
        "$@" ${attr}
}
test_is() {
        local VALUE="$1"; shift
        test "$($*)" = "${VALUE}"
}
map() {
        local ACTION="$1"; shift
        for x in "$@"
        do ${ACTION} "$x"
        done
}
map1() {
        local ACTION="$1"; shift
        local ARG1="$1";  shift
        for x in "$@"
        do ${ACTION} "${ARG1}" "$x"
        done
}
map2() {
        local ACTION="$1"; shift
        local ARG1="$1";  shift
        local ARG2="$1";  shift
        for x in "$@"
        do ${ACTION} "${ARG1}" "${ARG2}" "$x"
        done
}
unless() { local pred="$1";   shift; if test -z "${pred}";   then "$@"; fi
         }
when()   { local pred="$1";   shift; if test -n "${pred}";   then "$@"; fi
         }
say()    { local _quiet="$1"; shift; if test -z "${_quiet}"; then echo "$@"; fi
         }

iff() { local yes="$1" no="$2"; shift 2
        if "$@"
        then echo -n "$yes"
        else echo -n "$no"
        fi
}
ensure_trailing_newline() {
	sed '$a\'
}
remove_trailing_newline() {
        tr -d '\n'
}
remove_nonprintable() {
        tr -dc [:print:]
}
prefix_lines() {
        local prefix="$1"
	sed "s/^/${prefix}/; s/[ ]*\$//"
}
take_until_first_dot() {
        sed 's/^\([^\.]*\)\..*$/\1/'
}
keep_after_first_dot() {
        sed 's/^[^\.]*\.\(.*\)$/\1/'
}
keep_after_second_dot() {
        sed 's/^[^\.]*\.[^\.]*\.\(.*\)$/\1/'
}
keep_until_last_dot() {
        sed 's/^\(.*\)\.[^\.]*$/\1/'
}
one_per_line() {
        sed $'s/ /\\\n/'g
}
    #+END_SRC
*** Version comparison
#+BEGIN_SRC sh
function V() # $1-a $2-op $3-$b
# Author: stepse@StackOverflow: https://stackoverflow.com/a/48487783
# Compare a and b as version strings. Rules:
# R1: a and b : dot-separated sequence of items. Items are numeric. The last item can optionally end with letters, i.e., 2.5 or 2.5a.
# R2: Zeros are automatically inserted to compare the same number of items, i.e., 1.0 < 1.0.1 means 1.0.0 < 1.0.1 => yes.
# R3: op can be '=' '==' '!=' '<' '<=' '>' '>=' (lexicographic).
# R4: Unrestricted number of digits of any item, i.e., 3.0003 > 3.0000004.
# R5: Unrestricted number of items.
{
  local a=$1 op=$2 b=$3 al=${1##*.} bl=${3##*.}
  while [[ $al =~ ^[[:digit:]] ]]; do al=${al:1}; done
  while [[ $bl =~ ^[[:digit:]] ]]; do bl=${bl:1}; done
  local ai=${a%$al} bi=${b%$bl}

  local ap=${ai//[[:digit:]]} bp=${bi//[[:digit:]]}
  ap=${ap//./.0} bp=${bp//./.0}

  local w=1 fmt=$a.$b x IFS=.
  for x in $fmt; do [ ${#x} -gt $w ] && w=${#x}; done
  fmt=${*//[^.]}; fmt=${fmt//./%${w}s}
  printf -v a $fmt $ai$bp; printf -v a "%s-%${w}s" $a $al
  printf -v b $fmt $bi$ap; printf -v b "%s-%${w}s" $b $bl

  case $op in
    '<='|'>=' ) [ "$a" ${op:0:1} "$b" ] || [ "$a" = "$b" ] ;;
    * )         [ "$a" $op "$b" ] ;;
  esac
}
#+END_SRC
* Early init
*** Ensure config and PKGDB exist
#+BEGIN_SRC sh
init_pkgdb() {
        set -x
        local dir="$1" force="$2"

        if   test -e "${dir}" -a "${force}" != "--force"
        then fail "cannot make a new override database at '${dir}': already exists"
        elif test -z "${dir}"
        then fail "override DB location not specified"
        fi

        mkdir -p ${dir}/def/{over,meta,github,hackage}
        mkdir -p ${dir}/cache
        mkdir -p ${dir}/build/{log,drv,expr,src,success,failure{,-type,-log}}
        rm -f ${dir}/def/{over,meta,github,hackage}/*
        rm -f ${dir}/cache/*
        rm -f ${dir}/build/{log,drv,expr,src,success,failure{,-type,-log}}/*
        exit 0
}
validate_pkgdb() {
        local pkgdb="$1"
        test    -d ${pkgdb}/def/over    \
             -a -d ${pkgdb}/def/meta    \
             -a -d ${pkgdb}/def/github  \
             -a -d ${pkgdb}/def/hackage \
             -a -d ${pkgdb}/build
}
# Simulate disjoint types
LOGTY=build/log
DRVTY=build/drv
EXPRTY=build/expr
SRCTY=build/src
SUCCTY=build/success
FAILTY=build/failure
FAILTYTY=build/failure-type
FAILLOGTY=build/failure-log

emit_nh_config() {
        local PKGDB="$1" github_user="${2:-$USER}"
        cat <<EOF
GHC=${DEFAULT_GHC}
GHC_CONFIG=${DEFAULT_GHC_CONFIG}
PKGDB=${PKGDB}  # The override state database.
GITHUB_USER=${github_user}
EOF
}

emit_packages_nix() {
        cat <<EOF
{ nixpkgs     ? import <nixpkgs> {}
, pkgs        ? nixpkgs.pkgs, haskell ? pkgs.haskell
, compiler    ? "ghc${DEFAULT_GHC}"
, ghcOrig     ? pkgs.haskell.packages."\${compiler}"
}:

ghcOrig.override (oldArgs: {
    overrides = new: old:
    import ./overrides.nix { inherit pkgs; self = new; super = old; haskellLib = haskell.lib; };
  })
EOF
}

emit_shell_nix() {
        cat <<EOF
{ nixpkgs     ? import <nixpkgs> {}
, pkgs        ? nixpkgs.pkgs, haskell ? pkgs.haskell
, compiler    ? "ghc${GHC}"
, ghcOrig     ? pkgs.haskell.packages."\${compiler}"
, tools       ? false
, intero      ? tools
}:
let

  ghc     = import ${NIX_GHC_PACKAGE_SET} { inherit nixpkgs pkgs haskell compiler ghcOrig; };
  default = import ./.;
  drv     = ghc.callPackage default {};
  drv'    = haskell.lib.overrideCabal
            drv
            (old: {
              libraryHaskellDepends =
                old.libraryHaskellDepends
                ++ [ ghc.cabal-install ];
             });
in
  drv'.env
EOF
}

###
### Messy conflation of three requirements:
###  - find .nh in the parent directory hierarhy
###  - save NH_ROOT
###  - handle --init for depth=1
###
if   test -f .nh
then NH_ROOT="$(realpath .)"
elif test "$1" = "--init"
then shift
     emit_nh_config      "pkgdb" > .nh
     emit_packages_nix           > packages.nix
     if ! validate_pkgdb "pkgdb"
     then init_pkgdb     "pkgdb" --force
     fi
else NH_ROOT=$(realpath ..)
     while true
     do if   test -f ${NH_ROOT}/.nh
        then source  ${NH_ROOT}/.nh; break
        fi
        if   test    ${NH_ROOT} = "/"
        then  cat << EOF
ERROR: the .nh configuration file is present neither in the working directory,
       nor in the containing hierarchy.

Consider the following:  cat > .nh

$(emit_nh_config /home/user/configuration-ghc84x)

Don't have packages.nix?  cat > packages.nix

$(emit_packages_nix)

EOF
              exit 1
        fi
        NH_ROOT=$(realpath ${NH_ROOT}/..)
     done
fi

if test "$1" = "init"
then shift; init_pkgdb "$@"; fi

source ${NH_ROOT}/.nh
NIX_GHC_PACKAGE_SET=${NH_ROOT}/packages.nix
NIX_GHC_OVERRIDES=${NH_ROOT}/overrides.nix

if test -z "${PKGDB}" || ! validate_pkgdb "${PKGDB}"
then fail_untraced ".nh doesn't define PKGDB to point to a valid package database."; fi

if test -z "${NIX_GHC_PACKAGE_SET}"  -o ! -r ${NIX_GHC_PACKAGE_SET}
then fail_untraced ".nh doesn't define NIX_GHC_PACKAGE_SET to point to a readable file."; fi

NIXPKGS="$(nix-instantiate --eval -E '<nixpkgs>')"
if test $? != 0 -o -z "$NIXPKGS"
then fail "Unable to find Nixpkgs:  nix-instantiate --eval -E '<nixpkgs>'"
fi

if ! type nix-prefetch-git >/dev/null
then fail "missing tool:  nix-prefetch-git   (fix: nix-env -i nix-prefetch-scripts)"
fi

GHC_CONFIG_FULL_PATH=${NIXPKGS}/pkgs/development/haskell-modules/${GHC_CONFIG}

NIX_BUILD_OPTIONS="--argstr compiler ghc${GHC} --show-trace --cores 0"
#+END_SRC
* Nix
#+BEGIN_SRC sh
do_instantiate() {
        local attr="$1"; shift

        if !    nix-instantiate ${NIX_GHC_PACKAGE_SET} -A ${attr} --argstr compiler ghc${GHC} 2>/dev/null
        then
                nix-instantiate ${NIX_GHC_PACKAGE_SET} -A ${attr} --argstr compiler ghc${GHC} --show-trace
                return 1
        fi
}
nreferrers() {
        local attr="$1"; shift

        local drv=$(do_instantiate ${attr})
        local refs=$(nix-store --query --referrers-closure ${drv} | wc -l)
        echo ${refs} ${attr} ${drv}
}
nix_drv_src() {
        local drv="$1"; shift
        nix-store --query --binding src ${drv}
}
nix_attr_drv_sdrv() {
        local attr="$1"; shift
        local drv="$1"; shift
        nix-store --query --references ${drv} |
            grep "/nix/store/[1-z0-9]*-\(source\|${attr}-[0-9]\)" | grep -v '\.cabal\.drv$'
}
nix_src_drv_url() {
        local drv="$1"; shift
        nix-store --query --binding urls ${drv}
}
nix_drv_inputs() {
        local drv="$1"; shift
        { nix-store --query --binding buildInputs                 ${drv}
          nix-store --query --binding propagatedBuildInputs       ${drv}
          nix-store --query --binding propagatedNativeBuildInputs ${drv}
        } | one_per_line | grep -v '^$' | sort -t- -k2 | uniq
}

#+END_SRC
* PKGDB
*** Structural basis: TYPE/FIELD/NAME
#+BEGIN_SRC sh
path() {
        local TYPE="$1" FIELD="$2" NAME="$3"

        echo -n ${PKGDB}/${TYPE}/${NAME}.${FIELD}
}
_ls() {
        # List all overridden attributes.
        # NOTE:  this includes attributes whose overrides are disabled by meta/disable.
        local TYPE="${1:-def/over}"

        pushd ${PKGDB}/${TYPE} >/dev/null

        case $TYPE in
                def/over )                                 ls -1 *            2>/dev/null | take_until_first_dot | sort | uniq;;
                def/github | def/hackage )                 ls -1 *.${2:-hash} 2>/dev/null | sed "s/\\.${2:-hash}//";;
                build/success | build/failure )            ls -1 *            2>/dev/null | grep -v "\\.baseline$" | keep_until_last_dot | sort | uniq;;
                * ) echo "FATAL: listing of '${TYPE}' is not supported" >&2; popd; return 1;;
        esac | sort
        popd >/dev/null
}
by() {
        local TYPE="$1" FIELD="$2" VALUE="$3"
        shift 3

        for x in $(_ls ${TYPE})
        do if test "$(get ${TYPE} ${FIELD} $x)" = "${VALUE}"
           then echo $x
           fi
        done
}
lsattrs() {
        local TYPE="$1"; shift
        local NAME="$1"; shift

        pushd ${PKGDB}/${TYPE} >/dev/null
        ls -1 * 2>/dev/null | grep "^$NAME\\." | grep -v "\\.\(baseline$\|input\\.\)" | keep_after_first_dot
        popd >/dev/null
}
lsovers() {
        local NAME="$1"; shift

        pushd ${PKGDB}/def/over >/dev/null
        ls -1 $NAME.* 2>/dev/null | grep -v "^$NAME\\.input\\." | keep_after_first_dot
        popd >/dev/null
}
lsiovers() {
        local NAME="$1"; shift

        pushd ${PKGDB}/def/over >/dev/null
        ls -1 $NAME.input.* 2>/dev/null | keep_after_second_dot
        popd >/dev/null
}
hasiovers() {
        ls ${PKGDB}/def/over/$1.input.* >/dev/null 2>&1
}
hasanyovers() {
        ls ${PKGDB}/def/over/$1.* >/dev/null 2>&1
}
get() {
        local TYPE="$1" FIELD="$2" NAME="$3"

        if test -f ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        then   cat ${PKGDB}/${TYPE}/${NAME}.${FIELD} 2>/dev/null
        else return 1
        fi
}
get_def() {
        local DEFAULT="$4"

        get "$1" "$2" "$3" || echo -n "$DEFAULT"
}
has() {
        test -f $(path "$@")
}
_set() {
        local TYPE="$1" FIELD="$2" NAME="$3" VALUE="$4"

        if test -z "${VALUE}"
        then rm -f ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        else echo -n "${VALUE}" > ${PKGDB}/${TYPE}/${NAME}.${FIELD}
        fi
}
set_stdin() {
        local TYPE="$1" FIELD="$2" NAME="$3"

        cat > ${PKGDB}/${TYPE}/${NAME}.${FIELD}
}
edit() {
        local TYPE="$1";  shift
        local FIELD="$1"; shift
        local NAME="$1";  shift

        read -ep "${NAME}.${TYPE}.${FIELD}: " -i "$(get ${TYPE} ${FIELD} ${NAME})"
        _set "${TYPE}" "${FIELD}" "${NAME}" "${REPLY}"
}
reset_computed_state() {
        mkdir -p ${PKGDB}/{${LOGTY},${DRVTY},${EXPRTY},${SRCTY},${SUCCTY},${FAILTY},${FAILTYTY},${FAILLOGTY},cache}
        rm -f    ${PKGDB}/{${LOGTY},${DRVTY},${EXPRTY},${SRCTY},${SUCCTY},${FAILTY},${FAILTYTY},${FAILLOGTY}}/* 2>/dev/null ||
                true
}
stdin_only_enabled() {
        read attr || true
        while test -n "${attr}"
        do if ! test_overrides_disabled ${attr}
           then echo ${attr}
           fi
           read attr || true
        done
}
#+END_SRC
*** Mass manipulation
    #+BEGIN_SRC sh
forall_edit() {
        local TYPE="$1";  shift
        local FIELD="$1"; shift

        for name in $*
        do edit ${TYPE} ${FIELD} ${name}
        done
}
forall_defined_edit() {
        local TYPE="$1";  shift
        local FIELD="$1"; shift

        for name in $(filter has ${TYPE} ${FIELD})
        do edit ${TYPE} ${FIELD} ${name}
        done
}
stdin_forall_set() {
        local TYPE="$1" FIELD="$2" VALUE="$3"

        for name in $(cat)
        do _set "${TYPE}" "${FIELD}" ${name} "${VALUE}"
        done
}
    #+END_SRC
***** Queries
      #+BEGIN_SRC sh
filter() {
        for attr in $(_ls)
        do if "$@" ${attr} > /dev/null
           then echo ${attr}
           fi
        done
}
filter_by_and() {
        local pred="$1"; shift
        for attr in $(_ls)
        do if ${pred} ${attr} > /dev/null \
              && "$@" ${attr} > /dev/null
           then echo ${attr}
           fi
        done
}
overset_config() {
        (
                _ls def/over
                by  def/over src hackage
                by  def/over src github
        ) | sort | uniq -u
}
lstopo() {
        local TYPE="$1"

        local ntotal=$(_ls ${TYPE} | wc -l) ndone=1
        for attr in $(_ls ${TYPE})
        do
                echo -ne "\rComputing topology order: $ndone/$ntotal" >&2
                ndone=$((ndone+1))

                nreferrers ${attr}
        done | sort -nr
        echo >&2
}
get_nixpkgs_release() {
        local attr="$1"; shift

        nix-instantiate --eval -E "(import <nixpkgs> {}).pkgs.haskell.packages.ghc${GHC}.${attr}.version" | xargs echo -n
}
status() {
        local attr="$1"

        case $(get_def def/over src ${attr} maybe-config) in
        hackage ) if test_shadowed "$1"
                  then echo -n "shadowed"
                  else echo -n "hackaged"
                  fi;;
        github  ) if test_upstreamed "$1"
                  then echo -n "upstreamed"
                  else echo -n "unmerged"
                  fi;;
        maybe-config )
                  if hasanyovers "$1"
		  then echo -n "config"
		  else echo -n "default"
                  fi;;
        * )       echo "FATAL: invalid status for '${attr}': '$(get def/over src ${attr})'";;
        esac
}
ls_essential_reverse_deps() {
        for attr in $(_ls)
        do get def/meta erdeps ${attr} | xargs echo
        done | one_per_line | sort | uniq
}
ls_extra_validation_attributes() {
        get_def def/meta extra-validation-attributes | one_per_line | sort | uniq
}
ls_acme_deps() {
        { _ls
           ls_essential_reverse_deps
           ls_extra_validation_attributes
        } | sort | uniq | grep -v "^$" | stdin_only_enabled
}
      #+END_SRC
***** Logs
      #+BEGIN_SRC sh
get_log() {
        local over="$1"; shift
        local attr="$1"; shift

        get ${LOGTY} ${over} ${attr}
}
faillog() {
        local over="$1"; shift
        local attr="$1"

        test "$(get ${FAILTYTY} ${over} ${attr})" != UNKNOWN || {
                echo "WARNING: failure type UNKNOWN for:  ${attr}.${over}" >&2
                echo "WARNING: analyse (and maybe populate 'keysig'):  nh log ${attr} ${over}" >&2
                return 1
        }
        get ${FAILLOGTY} ${over} ${attr}
}
      #+END_SRC
*** Semantic mapping
#+BEGIN_SRC sh
attrName() {
        local attr="$1"; shift
        get_def def/meta attrName ${attr} "${attr}"
}
repoName() {
        local attr="$1"; shift
        get_def def/meta repoName ${attr} "${attr}"
}
set_repoName() {
        local attr="$1"; shift
        local repo="$1"; shift
        _set def/meta repoName ${attr} "${repo}"
}
edit_repoName() {
        local attr="$1"; shift
        edit def/meta repoName ${attr}
}
shadow_name() {
        local attr="$1";        shift
        has def/hackage release ${attr} &&
                echo "${attr}_$(get def/hackage release ${attr} | sed 's/\./_/g')"
}
test_is_local() {
	has def/meta local "$1"
}
test_is_nonlocal() {
	! has def/meta local "$1"
}
set_local() {
	_set def/meta local "$1" local
}
set_nonlocal() {
	_set def/meta local "$1" ""
}
repo_fixer() {
        local repo="$1"; shift
        get def/github user ${repo}
}
repo_upstream() {
        local repo="$1"; shift
        get def/github upstream ${repo}
}
repo_has_upstream() {
        local repo="$1"; shift
        has def/github upstream ${repo}
}
set_upstream() {
        local attr="$1"; shift
        local upstr="$1"; shift
        _set def/github upstream $(repoName "$attr") "$upstr"
}
edit_upstream() {
        local attr="$1"; shift
        edit def/github upstream $(repoName "$attr")
}
fix_commit() {
        local attr="$1"; shift

        get def/github rev $(repoName "${attr}")
}
fix_timestamp() {
        local attr="$1"; shift
        get def/github timestamp $(repoName "${attr}")
}
ghc_configuration_fixed_content() {
        get_def def/meta ghc-configuration-fixed-content
}
test_suggested_by_trim() {
        local over=$1; shift
        local attr=$1; shift
        has ${SUCCTY} "${over}" ${attr}
}
test_known() {
        local attr="$1"
        local repo="$(repoName "${attr}")"
        has def/github upstream "${repo}"
}
get_iover() {
        local ATTR="$1" INPUT="$2"

        get def/over input.${INPUT} "${ATTR}"
}
set_iover() {
        local ATTR="$1" INPUT="$2" VAL="$3"

        _set def/over input.${INPUT} "${ATTR}" "$VAL"
}
test_override_disabled() {
        local over="$1"; shift
        local attr="$1"
        has def/meta disable.${over} "${attr}"
}
test_overrides_disabled() {
        local attr="$1"
        has def/meta disable "${attr}"
}
#+END_SRC
*** Shadowing
#+BEGIN_SRC sh
shadows() {
        local attr="$1"; shift
        local nixpkgs="${2:-/home/deepfire/src/nixpkgs}"

        local hackage_packages=${NIXPKGS}/pkgs/development/haskell-modules/hackage-packages.nix

        if test ! -f "${hackage_packages}"
        then echo "FATAL: ${nixpkgs} doesn't point to a valid Nixpkgs checkout"; return 1
        fi

        grep "${attr}_.* = callPackage" ${hackage_packages} | cut -d'"' -f2
}
test_shadow_exists() {
        local attr="$1"; shift

        local shadow=$(shadow_name ${attr} || true)
        test "$(get def/over src $attr)" = "hackage" -a -n "$shadow" && { shadows ${attr} | grep -q "$shadow"; }
}
test_shadowed() {
        local attr="$1"; shift

        test_shadow_exists "${attr}" && ! has def/meta suppress-shadow "${attr}" ## XXX: re-use the 'disable' mechanism
}
#+END_SRC
*** Status & auto-import
    #+BEGIN_SRC sh
upstream() {
        local _attr="$1"
        local _repo="$(repoName "${_attr}")"

        if ! has def/github upstream "${_repo}"
        then import_hackage_cabal "${_attr}" >&2
             _repo="$(repoName "${_attr}")"
        fi
        get def/github upstream ${_repo}
}
test_upstreamed() {
        local upstr="$(upstream $1)"
        local  repo="$(repoName $1)"
        local  user="$(repo_fixer $repo)"

        test -n "${user}" -a "${user}" = "${upstr}"
}
    #+END_SRC
*** Nix
    #+BEGIN_SRC sh
attr_override_drv_src() {
        local over="$1"; shift
        local attr="$1"; shift
        nix_drv_src ${PKGDB}/${DRVTY}/${attr}.${over}
}
    #+END_SRC
*** Network
***** endpoint-head/body/field
  #+BEGIN_SRC sh
endpoint_body() {
        curl --silent    $(url "$@")
}
endpoint_head() {
        curl --silent -I $(url "$@")
}
endpoint_test_status() {
        local status="$1"; shift
        endpoint_head "$@" | grep -q "${status}"
        test ${PIPESTATUS[0]} = 0 -a ${PIPESTATUS[1]} = 0
}
endpoint_field() {
        local field="$1"; shift
        endpoint_head "$@" | grep "^${field}: " | cut -d' ' -f2-
        test ${PIPESTATUS[0]} = 0
}
  #+END_SRC
***** url
      #+BEGIN_SRC sh
prOrFail() {
        local repo="$1"
        get def/github pr $repo || {
                echo "FATAL:  pull-request not specified for github repo '${repo}'" >&2
                fail " logs:  get def/github pr ${repo}"
        }
}
issueOrFail() {
        local repo="$1"
        get def/github issue $repo || {
                echo "FATAL:  issue ID not specified for github repo '${repo}'" >&2
                fail " logs:  get def/github issue ${repo}"
        }
}
upstreamOrFail() {
        local _attr="$1"
        upstream "${_attr}" ||
             fail "unable to deduce upstream for '${_attr}'"
}
url() {
        local KIND="$1"; shift
        local attr="$1"; shift

        local subpath= gitrev=master pull_request= issue= release=
        while test $# -ge 1
        do case "$1"
           in --subpath )              subpath="$2"; shift;;
              --gitrev )               gitrev="$2";  shift;;
              --pull-request )         pull_request="$2";  shift;;
              --issue )                issue="$2";  shift;;
              --release )              release="$2"; shift;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )     break;;
           esac
           shift
        done

        local repo="$(repoName "${attr}")"
        case "${KIND}" in
                upstream-github-cabal )      local upstream="$(upstream "${attr}")"
                                             repo="$(repoName "${attr}")"
                                             echo -n "https://raw.githubusercontent.com/$(upstreamOrFail   $attr)/$repo/${gitrev}/$subpath$attr.cabal";;
                user-github-cabal )          echo -n "https://raw.githubusercontent.com/$(repo_fixer $repo)/$repo/${gitrev}/$subpath$attr.cabal";;
                upstream-github )            echo -n "https://github.com/$(               upstreamOrFail   $attr)/$repo";;
                upstream-pulls )             echo -n "https://github.com/$(               upstreamOrFail   $attr)/$repo/pulls";;
                user-github )                echo -n "https://github.com/$(               repo_fixer $repo)/$repo";;
                self-github )                echo -n                    "git@github.com:$(echo   $GITHUB_USER)/$repo";;
                upstream-pull-request )      echo -n "https://github.com/$(               upstreamOrFail   $attr)/$repo/pull/$(prOrFail $repo)";;
                upstream-issue )             echo -n "https://github.com/$(               upstreamOrFail   $attr)/$repo/issues/$(issueOrFail $repo)";;
                commits | upstream-commits ) echo -n "https://github.com/$(               upstreamOrFail   $attr)/$repo/commits/master";;
                user-commits )               echo -n "https://github.com/$(               repo_fixer $repo)/$repo/commits/master";;
                hackage )                    echo -n "https://hackage.haskell.org/package/$attr";;
                hackage-package )            echo -n "https://hackage.haskell.org/package/$attr-$release/$attr-$release.tar.gz";;
                hackage-cabal )              echo -n "https://hackage.haskell.org/package/$attr/$attr.cabal";;
                pull-merged )                echo -n "https://api.github.com/repos/$(     repo_fixer $repo)/$repo/pulls/$(prOrFail $repo)/merge";;
                commit )                     echo -n "https://api.github.com/repos/$(     repo_fixer $repo)/$repo/commits?sha=${gitrev}";;
                github-requests-remaining )  echo -n "https://api.github.com/rate_limit";;
                * ) fail "invalid URL kind: '$KIND'";;
        esac
}
      #+END_SRC
*** Removal
***** remove
    #+BEGIN_SRC sh
remove() {
        local attr="$1"; shift
        local overset="${1:-$(lsattrs def/over ${attr})}"; shift
        for over in ${overset}
        do _set def/over ${over} ${attr} ""
        done
}
#+END_SRC
* Queries
*** Classification
***** Stream filtering
  #+BEGIN_SRC sh
log_filter_failure() {
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        grep '^builder for.*failed with exit code 1' | sed 's|.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|\1|'
}
log_filter_success() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        grep '^checking for references to.* in /nix/store/.*\.\.\.' | sed 's|.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|\1|'
}
log_filter_result() {
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        grep --line-buffered '^builder for.*failed with exit code 1\|^checking for references to.* in /nix/store/.*[0-9]\.\.\.' | sed 's|^builder for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|FAIL: \1|' | sed 's|checking for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|OK: \1|'
}
log_filter_progress() {
        # error: while evaluating the attribute ‘propagatedBuildInputs’ of the derivation ‘nh-acme-grand-total-attribute-0.0.0’ at /home/deepfire/nixpkgs/pkgs/stdenv/generic/make-derivation.nix:148:11:
        # error: while evaluating anonymous function at /home/deepfire/hpack/shell.nix:1:1, called from undefined position:
        # checking for references to /tmp/nix-build-wl-pprint-annotated-0.1.0.0.drv-0 in /nix/store/cvvhr1faa5ha2kw9jx0n1kf9i7s20di8-wl-pprint-annotated-0.1.0.0-doc...
        # builder for ‘/nix/store/fqdjapba0wndjcwq446w54pg0makrr4p-cereal-0.5.4.0.drv’ failed with exit code 1
        # setupCompileFlags: -package-db=/tmp/nix-build-hedgehog-0.5.1.drv-0/package.conf.d -j8 -threaded
        grep --line-buffered '^error: while evaluating \|^builder for.*failed with exit code 1\|^checking for references to.* in /nix/store/.*[0-9]\.\.\.\|setupCompileFlags: -package-db=/tmp/nix-build-.*' |
            sed 's|^builder for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|FAIL: \1|' |
            sed 's|checking for.*/nix/store/[a-z0-9]*-\([a-zA-Z0-9-]*\)-[0-9].*$|OK:   \1|' |
            sed 's|setupCompileFlags: -package-db=/tmp/nix-build-\([a-zA-Z0-9-]*\)-[0-9].*$|NEW:  \1|'
}
log_filter_evaluation_failure_attributes() {
        local grep_extra="$1"
        grep "while evaluating the attribute${grep_extra}" | sed 's/.*derivation ‘\(.*\)’ at.*/\1/'
}
  #+END_SRC
***** Failure log classification
  #+BEGIN_SRC sh
declare -a keysig
keysig=(
"CABAL-MISSING-DEPS||||Setup: Encountered missing dependencies"
"HASKELL-SMP-NO-INSTANCE-FOR||||No instance for \(Semigroup"
"HASKELL-SMP-COULD-NOT-DEDUCE||||Could not deduce \(Semigroup"
"HASKELL-SMP-APPEND-CONFLICT||||Ambiguous occurrence ‘<>’"
"HASKELL-SMP-NO-INSTANCE-IMPL-FOR||||No instance nor default method for class operation <>"
"HASKELL-SMP-VERSION||||Module ‘Data.Semigroup’ does not export ‘"
"GHC-BUG||||Please report this as a GHC bug"
"CABAL-NOT-FOUND||||/bin/sh: cabal: command not found"
"NO-SUCH-FILE-OR-DIRECTORY||||: No such file or directory"
"NIX-ERROR-EVAL-OVERRIDECABAL||||error: while evaluating ‘overrideCabal’"
"JAILBREAK-CABAL-MISSING-CABAL||||jailbreak-cabal: dieVerbatim: user error \(jailbreak-cabal: Error Parsing: file "
"CABAL-CONFIGURE-MISSING-PROGRAM||||Setup: The program '[A-Za-z-]*' is required but it could not be found"
"NIX-MISSING-ATTRIBUTE||||error: attribute ‘[A-Za-z-]*’ in selection path ‘[A-Za-z-]*’ not found"
"HASKELL-MISSING-EXPORT||||Module ‘[A-Za-z-]*’ does not export ‘"
"HASKELL-AMBIGUOUS-TYPE-VARIABLE-ERROR||||Ambiguous type variable"
"HASKELL-TYPE-ERROR||||Couldn't match expected type"
"HASKELL-MISSING-INSTANCE||||No instance for \("
"HASKELL-CONTEXT-NOT-SATISFIED||||Could not deduce \("
"HASKELL-MISSING-MODULE||||Could not find module ‘"
"HASKELL-VAR-NOT-IN-SCOPE||||Variable not in scope:"
"CURL-404||||The requested URL returned error: 404 Not Found"
"NO-SUCH-FILE-OR-DIRECTORY||||No such file or directory"
"NO-CABAL-FILE-FOUND||||Setup: No cabal file found"
"TH-RUNTIME-EXCEPTION||||Exception when trying to run compile-time code:"
"INSTANTIATE-INFINITE-RECURSION||||infinite recursion encountered, at undefined"
"INSTANTIATE-GENERIC||||error: while evaluating the attribute"
"HADDOCK-INTERNAL-ERROR||||haddock: internal error:"
"TESTSUITE-FAILURE||||^Failures:$"
"NIX-ERROR-EVAL-ANON||||^error: while evaluating anonymous function at$"
"HASKELL-DUPLICATE-INSTANCE||||Duplicate instance declarations:"
"HADDOCK-CABAL-INTERNAL-ERROR||||Setup: internal error when calculating transitive package dependencies."
)
declare -A grepctx
grepctx["CABAL-MISSING-DEPS"]="-A5"
grepctx["HASKELL-SMP-NO-INSTANCE-FOR"]="-A2"
grepctx["HASKELL-SMP-COULD-NOT-DEDUCE"]="-A2"
grepctx["HASKELL-SMP-APPEND-CONFLICT"]="-A2"
grepctx["HASKELL-SMP-VERSION"]="-A2"
grepctx["GHC-BUG"]="-B30"
grepctx["HASKELL-TYPE-ERROR"]="-A3"
grepctx["HASKELL-MISSING-INSTANCE"]="-A2"
grepctx["HASKELL-CONTEXT-NOT-SATISFIED"]="-A2"
grepctx["CURL-404"]="-A1"
grepctx["TH-RUNTIME-EXCEPTION"]="-B1 -A7"
grepctx["INSTANTIATE-INFINITE-RECURSION"]="-B10"
grepctx["INSTANTIATE-GENERIC"]="-A7"
grepctx["HADDOCK-INTERNAL-ERROR"]="-A7"
grepctx["TESTSUITE-FAILURE"]="-A10"
grepctx["NIX-ERROR-EVAL-ANON"]="-A10"
grepctx["HASKELL-DUPLICATE-INSTANCE"]="-B1 -A3"
grepctx["HADDOCK-CABAL-INTERNAL-ERROR"]="-B1 -A2"
  #+END_SRC
***** fail-classify-one-property
      #+BEGIN_SRC sh
fail_classify_one_property() {
        local over="$1"; shift
        local attr="$1"; shift
        local no_state_change="$1"

        for ks in "${keysig[@]}"
        do local key="${ks%%||||*}" sig="${ks#*||||}"
           if      get_log ${over} ${attr} | egrep --max-count=1 -q                 "${sig}"
           then
                   echo "${key}"
                   if test -z "${no_state_change}"
                   then _set ${FAILTYTY} ${over} ${attr} "${key}"
                   fi
                   get_log ${over} ${attr} | egrep --max-count=1 ${grepctx["${key}"]} "${sig}" \
			| grep -v "^$\|^builder for ‘/nix/store/\|^error: build of ‘/nix/store/" |
                           { if test -n "${no_state_change}"
                             then cat
                             else tee $(path ${FAILLOGTY} ${over} ${attr})
                             fi; }
                   return 0
           fi
        done
        echo UNKNOWN
        _set ${FAILTYTY} ${over} ${attr} UNKNOWN
        return 1
}
      #+END_SRC
*** Cabal
***** hackage-cabal
      #+BEGIN_SRC sh
hackage_cabal() {
        local attr="$1"; shift
        endpoint_body hackage-cabal ${attr}
}
      #+END_SRC
***** github-cabal
      #+BEGIN_SRC sh
github_cabal() {
        local kind="$1"; shift
        local attr="$1"; shift
        local gitrev="${1:-master}"
        local chdir="$(get_def def/meta chdir $attr '')"

        curl -sL $(url ${kind}-github-cabal $(attrName ${attr}) --subpath "${chdir}${chdir:+/}" --gitrev "${gitrev}")
}
      #+END_SRC
*** Hackage
***** hackage-cabal-chdir / upstream-url
      #+BEGIN_SRC sh
hackage_cabal_chdir() {
        local attr="$1"; shift
        local ret=$(hackage_cabal ${attr} | sed -n '/^[Ss]ource-repository head/,$ p' | grep -i "subdir:" |
                    sed 's,^.*ubdir:[ ]*\(.*\)$,\1,' |
                    remove_nonprintable)
        if test ${PIPESTATUS[0]} = 0 -a -n "$ret"
        then echo -n "$ret"
        else return 1
        fi
}
hackage_cabal_upstream_url() {
        local attr="$1"; shift
        local ret=$(hackage_cabal ${attr} | sed -n '/^[Ss]ource-[Rr]epository head/,$ p' | grep -i "location:" | remove_nonprintable |
                    sed 's,^.*ocation:[ ]*\(https://\|git://\|git@\)\(github.com\)[/:]\(.*\)\.git$,https://\2/\3,;s,^.*ocation:[ ]*\(https\|git\)\(://github.com/.*\)$,https\2,')
        if test ${PIPESTATUS[0]} = 0 -a -n "$ret"
        then echo -n "$ret"
        else return 1
        fi
}
      #+END_SRC
***** hackage-release-date / timestamp
      #+BEGIN_SRC sh
test_hackage_release() {
        local release="$1"; shift
        local attr="$1"; shift

        endpoint_test_status 'HTTP/1.1 200 OK' hackage-package ${attr} --release ${release}
}
hackage_release_date() {
        local attr="$1"; shift
        local release="$1"; shift

        local ret="$(endpoint_field 'Last-modified' hackage-package ${attr} --release ${release})"
        if test -z "${ret}"
        then return 1
        else echo -n "${ret}"
        fi
}
hackage_release_timestamp() {
        local date=$(hackage_release_date "$@")
        if test $? != 0
        then return 1
        fi
        date -d "$date" +%s
}
      #+END_SRC
***** hackage-ahead-of-fix
  #+BEGIN_SRC sh

hackage_ahead_of_fix() {
        local attr="$1"
        local upstream_release=$(get_upstream_release ${attr})
        if test_hackage_release ${upstream_release} ${attr}
        then
                local hackage_timestamp=$(hackage_release_timestamp ${attr} ${upstream_release})
                local fix_stamp=$(fix_timestamp ${attr})
                test ${fix_stamp} -le ${hackage_timestamp}
        else
                return 1
        fi
}
  #+END_SRC
*** Github
***** repo-url-*
  #+BEGIN_SRC sh
## https://github.com/sdiehl/protolude
github_repo_githttp_url_user() {
   cut -d/ -f4 <<< $1
}
github_repo_githttp_url_repo() {
   cut -d/ -f5 <<< $1 | sed 's/\.git$//'
}
## git@github.com:sdiehl/protolude.git
github_repo_gitssh_url_user() {
   sed 's|.*:\([^/]*\)/\([^/]*\)\.git$|\1|' <<< $1
}
github_repo_gitssh_url_repo() {
   sed 's|.*:\([^/]*\)/\([^/]*\)\.git$|\2|' <<< $1
}
  #+END_SRC
***** commit-date / timestamp
      #+BEGIN_SRC sh
commit_date() {
        local attr="$1"; shift
        local gitrev="${1:-master}"

        endpoint_field "Last-Modified" commit "${attr}" --gitrev "${gitrev}"
        return ${PIPESTATUS[0]}
}
commit_timestamp() {
        local date="$(commit_date "$@")"
        if test $? != 0
        then return 1
        fi
        date -d "$date" +%s
}
      #+END_SRC
***** get-{upstream,user}-release
      #+BEGIN_SRC sh
get_upstream_release() {
        local attr="$1"; shift
        local gitrev="${1:-master}"
        github_cabal upstream ${attr} ${gitrev} | grep -i '^version:' | sed 's/[vV]ersion:[ ]*//' | remove_nonprintable
}
get_user_release() {
        local attr="$1"; shift
        local gitrev="${1:-master}"
        github_cabal user ${attr} ${gitrev} | grep -i '^version:' | sed 's/[vV]ersion:[ ]*//' | remove_nonprintable
}
      #+END_SRC
***** pull-request-status
  #+BEGIN_SRC sh
pull_request_status() {
        local attr="$1"; shift
        local repo="$(repoName "$attr")"
        local pull_request="$(get_def def/github pr ${repo} '')"


        local http_code="$(endpoint_head pull-merged ${attr} --pull-request ${pull_request} | grep 'HTTP/1.1')"

        if   echo "${http_code}" | grep -q "204 No Content"
        then echo -n "merged"
        elif echo "${http_code}" | grep -q "404 Not Found"
        then echo -n "unmerged"
        else return 1
        fi
}
  #+END_SRC
***** issue-state
  #+BEGIN_SRC sh
issue_state() {
        ## XXX: untested
        local attr="$1"; shift
        local repo="$(repoName "$attr")"
        local issue="$(get_def def/github issue ${repo} '')"

        local state="$(endpoint_head issue ${attr} --issue ${issue} | grep '^  "state": ' | cut -d'"' -f4)"

        case "${state}" in
             open | closed ) echo -n ${state};;
             * )             return 1;;
        esac
}
  #+END_SRC
***** github-requests-remaining
  #+BEGIN_SRC sh
github_requests_remaining() {
        endpoint_field "X-RateLimit-Remaining" github-requests-remaining
}
  #+END_SRC
*** info
    #+BEGIN_SRC sh
info() {
        local attr="$1"
        if ! test_known "${attr}"
        then import_hackage_cabal "${attr}"
        fi
        local repo=$(repoName ${attr})
                   cat <<EOF
attribute '${attr}':

                  $(status  ${attr} | tr a-z A-Z)
                target: $(if test_is_local ${attr}
                          then echo 'local overrides'
                          else echo 'nixpkgs'
                          fi)
             overrides: $(lsattrs def/over ${attr} | xargs echo -n)
          upstream URL: $(if has def/github upstream $(repoName ${attr}); then url upstream-github ${attr}; fi)
EOF
                   local input_overs="$(lsiovers ${attr})"
                   if test -n "${input_overs}"
                   then cat <<EOF
       input overrides:
EOF
                        for iover in ${input_overs}
                        do cat <<EOF
  $(printf "%22s" ${iover}): $(get_iover ${attr} ${iover})
EOF
                        done
                   fi

                   case $(status  ${attr}) in
                           hackaged | shadowed )
                   cat <<EOF
      override release: $(get def/hackage release ${attr})
EOF
                   ;;
                           upstreamed )
                   local rev=$(get def/github rev ${repo})
                   cat <<EOF
              upstream: $(repo_upstream ${repo})
          override rev: ${rev}
      override release: $(get_upstream_release ${attr} ${rev})
EOF
                   ;;
                           unmerged )
                   cat <<EOF
              upstream: $(repo_upstream      ${repo})
                  user: $(repo_fixer         ${repo})
          override rev: $(get def/github rev ${repo})
      override release: $(get_user_release ${attr})
          pull request: $(url upstream-pull-request ${attr})
EOF
                   ;;
                   esac
                   if has def/github issue ${repo}
                   then cat <<EOF
                 issue: $(url upstream-issue ${attr})
EOF
                   fi
                   cat <<EOF
                  meta: $(lsattrs def/meta ${attr} | xargs echo -n)
EOF
                   if has def/meta erdeps ${attr}
                   then cat <<EOF
     essential revdeps: $(get def/meta erdeps ${attr} | xargs echo -n)
EOF
                   fi
                   if test -n "$(attrs_suggested_by_trim ${attr})"
                   then cat <<EOF
      trim suggestions: $(attrs_suggested_by_trim ${attr})
EOF
                   fi
                   overview_one "${attr}"
}
    #+END_SRC
*** overview
#+BEGIN_SRC sh
overview_one() {
        local attr="$1"; shift
        local status="${1:-$(status ${attr})}"
        local upstream_release="$(get_upstream_release ${attr})"
        cat <<EOF
              upstream: ${upstream_release}
               nixpkgs: $(get_nixpkgs_release ${attr})
               commits: $(url upstream-commits ${attr})
         pull requests: $(url upstream-pulls ${attr})
               hackage: $(url hackage ${attr})
  last upstream release on hackage: $(iff yes no test_hackage_release ${upstream_release} ${attr})
  hackage release date: $(hackage_release_date ${attr} ${upstream_release})
EOF
        case ${status} in
          upstreamed ) cat <<EOF
       fix commit date: $(date -d @$(fix_timestamp ${attr}))"
EOF
;;
          unmerged )   cat <<EOF
          pull request: $(url upstream-pull-request ${attr})"
EOF
;;
        esac
        local trs="$(attrs_suggested_by_trim ${attr})"
        if test -n "${trs}"
        then cat <<EOF
      trim suggestions: ${trs}
EOF
        fi
}
overview() {
        if test $# -gt 0
        then for attr in "$@"
             do overview_one ${attr}
             done
             return 0
        fi
        for status in shadowed hackaged upstreamed unmerged config
        do cat <<EOF

## ${status}
##
EOF
           for attr in $(filter test_is "$status" status)
           do echo         ${attr}
              overview_one ${attr} ${status}
           done
        done
}
#+END_SRC
* Override caching and emission
*** cache-gen-override-one
    #+BEGIN_SRC sh
cache_gen_override_one() {
        local attr="$1"; shift
        local REQUIRE_DESC="$2"

        emit_override ${attr} "${REQUIRE_DESC}" | set_stdin cache override ${attr}
        if test ${PIPESTATUS[0]} != 0
        then fail "failed to compute override for ${attr}"
        fi
}
    #+END_SRC
*** coherently
#+BEGIN_SRC sh
coherently() {
        local reuse_cache= reuse_overrides= require_desc= quiet=${NH_QUIET}
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --require-desc )         require_desc="--require-desc";;
              --quiet )                quiet="--quiet";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local attr=$1; shift
        local over=$1; shift

        emit_override ${attr} ${require_desc} | set_stdin cache override ${attr}
        if test ${PIPESTATUS[0]} != 0
        then fail "failed to compute override ${attr}"
        fi
        unless "${quiet}" get cache override ${attr}

	# Record the overall expression used.
        if test ${over} = "baseline"
        then local savename=baseline
        else local savename=${attr}.${over}
        fi
        if test -z "${reuse_overrides}"
        then apply ${reuse_cache} ${quiet}
        fi
        cp      -f ${NIX_GHC_OVERRIDES}    ${PKGDB}/${EXPRTY}/${savename}
        if test -n "${TARGET_NIXPKGS}"
        then cp -f ${GHC_CONFIG_FULL_PATH} ${PKGDB}/${EXPRTY}/${savename}.ghc
        fi

        "$@"
}
cache_copy() {
        local FIELD_FROM="$1"; shift
        local FIELD_TO="$1";   shift

        pushd ${PKGDB}/cache >/dev/null
        for from in *.${FIELD_FROM}
        do
                local to="$(echo -n $from | keep_until_last_dot)".${FIELD_TO}
                cp -f "${from}" "${to}"
        done
	popd >/dev/null
}
    #+END_SRC
*** cache
#+BEGIN_SRC sh
cache() {
        local require_descs= quiet=${NH_QUIET}
        while test $# -ge 1
        do case "$1"
           in --require-descs )        require_descs="require-descs";;
              --quiet )                quiet="quiet";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done
	mkdir -p   ${PKGDB}/cache

        tracing_suspend cache

        local ATTRSET="$*"
        local header="\r$(iff Reg G test -z "${ATTRSET}")enerating override cache"
        if test -z "${ATTRSET}"
        then rm -f ${PKGDB}/cache/*
             ATTRSET="$(_ls def/over | xargs echo -n)"
        fi

        local ntotal=$(echo -n ${ATTRSET} | wc -w)
        local ndone=1
        for attr in ${ATTRSET}
        do say "${quiet}" -ne "${header}: $ndone/$ntotal" >&2
           ndone=$((ndone+1))

           cache_gen_override_one ${attr} ${require_desc}
        done
        say "${quiet}" >&2

        tracing_resume cache
}
#+END_SRC
*** Explanations
  #+BEGIN_SRC sh
emit_explanation() {
        local over="$1"; shift
        local attr="$1"; shift

        if test -z "${over}"
        then case $(status ${attr}) in
                     shadowed   ) echo "Needs bump to a versioned attribute";;
                     hackaged   ) echo "On Hackage, awaiting for import";;
                     upstreamed ) echo "Upstreamed, awaiting a Hackage release";;
                     unmerged   ) echo "Unmerged.  PR: $(url upstream-pull-request ${attr})";;
             esac
             local repo="$(repoName "$attr")"
             if has def/github issue ${repo}
             then echo "Issue: $(url upstream-issue ${attr})"
             fi
        fi
        faillog "${over}" ${attr}                | ensure_trailing_newline
	get def/meta ${over}.explanation ${attr} | ensure_trailing_newline
}
emit_src_description() {
        local attr="$1"; shift

        case "$(get def/over src ${attr})" in
                hackage )    echo "    ## Hackage import needed";;
                github )
                        if test_upstreamed "${attr}"
                        then echo "    ## Fixes upstreamed, awaiting Hackage release"
                        else echo "    ## Fixes not upstream yet"
                        fi;;
        esac
}
  #+END_SRC
*** emit-definition
  #+BEGIN_SRC sh
emit_definition() {
        local attr="$1"; shift
        cat <<EOF
  ${attr} = new.mkDerivation {
    pname = "${attr}";
  };
EOF
}
  #+END_SRC
*** emit-property-override
  #+BEGIN_SRC sh
fail_uncached() {
        echo -e "\nERROR: attribute $1 has no override cache" >&2
        echo "    ### XXX: broken/inconsistent attribute $1"
        # exit 1
}
emit_property_override() {
        local attr="$1"; shift
        local propNameExtra="$1"; shift
        local propName=${propNameExtra%Extra}
        eval "local ${propName}=\"$(get_def def/over ${propName} ${attr})\""
        eval local propVal=\$$propName
        if test ! -z "${propVal}" && ! has def/meta disable.${propName} ${attr}
        then
                emit_explanation ${propName} ${attr} | prefix_lines "    ## "
                if test ! -z "${REQUIRE_DESC}" -a ${PIPESTATUS[0]} != 0
                then fail "missing failure log for ${attr}.${propName}, and couldn't compute it either:  nh x emit_explanation ${propName} ${attr}"
                fi
                case "${propNameExtra}" in
                        src )
                                case "$src" in
                                        hackage )
                                                if test_shadowed "${attr}"
                                                then echo "    ##"
                                                else
                                                cat <<EOF
    version         = "$(get def/hackage release ${attr})";
    sha256          = "$(get def/hackage hash    ${attr})";
EOF
                                                fi;;
                                        github )
                                                local repo=$(repoName ${attr})
                                                cat <<EOF
    src = pkgs.fetchFromGitHub {
      owner  = "$(repo_fixer ${repo})";
      repo   = "${repo}";
      rev    = "$(get def/github rev  ${repo})";
      sha256 = "$(get def/github hash ${repo})";
    };
EOF
                                                if has def/meta chdir ${attr}
                                                ## XXX: change to:
                                                then echo "    prePatch        = \"cd $(get def/meta chdir ${attr}); \";"
                                                fi;;
                                        * )     fail "unknown value for src override: '$src'";;
                                esac;;
                        doCheck )          echo "    doCheck         = ${doCheck};";;
                        doHaddock )        echo "    doHaddock       = ${doHaddock};";;
                        jailbreak )        echo "    jailbreak       = ${jailbreak};";;
                        editedCabalFile )  echo "    editedCabalFile = ${editedCabalFile};";;
                        revision )         echo "    revision        = ${revision};";;
                        postPatch )        echo "    postPatch       = \"${postPatch}\";";;
                        *Extra )           emit_depends_extra "${propName}" "${propVal}";;
                        * ) fail "unknown property: '${propName}'";;
                esac
        fi
}
EXTRA_PROPS="$(echo {setup,library,executable,test,benchmark}{Haskell,System,Pkgconfig,Tool})"
EXTRA_PROPS_HANDLED_EXTRAED="libraryHaskellExtra"
EXTRA_PROPS_CASE="$(sed 's/ / | /g' <<< "${EXTRA_PROPS}")"
validate_depends_extra_name() {
        eval "case $1 in ${EXTRA_PROPS_CASE} ) return 0;; * ) return 1;; esac"
}
emit_depends_extra() {
        local key="$1"; shift
        local val="$1"; shift
        if ! validate_depends_extra_name "${key}"
        then fail "invalid extra depends key: ${key}"
        fi
        echo "    ${key}Depends = (if builtins.hasAttr \"${key}Depends\" drv then drv.${key}Depends else []) ++ (with self; [ ${val} ]);";
}
  #+END_SRC
*** emit-input-overrides
#+BEGIN_SRC sh
emit_input_overrides() {
        local attr="$1"; shift
        if ! hasiovers "${attr}"
        then return 0
        fi
        cat <<EOF
.override {
EOF
        for iover in $(lsiovers ${attr})
        do emit_explanation input.${iover} ${attr} | prefix_lines "    ## "
           cat <<EOF
    ${iover} = $(get_iover ${attr} ${iover});
EOF
        done
        echo -n "  }"
}
#+END_SRC
*** emit-override
  #+BEGIN_SRC sh
emit_override() {
        local attr="$1"; shift
        local base_attr=""

        if ! hasanyovers "${attr}" || test_overrides_disabled "${attr}"
        then return
        fi
        local shadowed base_attr overs="$(lsovers ${attr})"
        if test_shadowed "${attr}" && ! test_override_disabled src "${attr}"
	then shadowed=yes; base_attr="$(shadow_name ${attr})"
        else shadowed=;    base_attr="${attr}"
        fi
        emit_explanation ""  ${attr} | prefix_lines "  ## " # Print general context first
        if test -z "${overs}" || (test "${overs}" = "src" && test -n "${shadowed}")
        then
                if test "${overs}" = "src"
                then emit_explanation src ${attr} | prefix_lines "  ## "
                fi
                cat <<EOF
  ${attr} = super.${base_attr}$(emit_input_overrides ${attr});

EOF
        else
                local ioob= iocb=
                if hasiovers "${attr}"
                then ioob="("; iocb=")"
                else ioob="";  iocb=""
                fi
                cat <<EOF
  ${attr} = ${ioob}overrideCabal super.${base_attr} (drv: {
EOF
                local props="src doCheck doHaddock jailbreak editedCabalFile revision postPatch ${EXTRA_PROPS_HANDLED_EXTRAED}"
                for p in ${props}
                do emit_property_override ${attr} $p
                done
                cat <<EOF
  })${iocb}$(emit_input_overrides ${attr});

EOF
        fi
}
  #+END_SRC
*** do-emit-overrides
  #+BEGIN_SRC sh
do_emit_overrides() {
        local predicate="true" quiet=${NH_QUIET}
        while test $# -ge 1
        do case "$1"
           in --target )               case "$2" in
                                           local )   predicate=test_is_local;    shift;;
                                           nixpkgs ) predicate=test_is_nonlocal; shift;;
                                           * ) fail "unexpected --target: '$2'";; esac;;
              --quiet)                 quiet="--quiet";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done
        tracing_suspend emit-overrides

        cat <<EOF
  ## Shadowed:

EOF
        for attr in $(filter_by_and ${predicate} test_is shadowed status)
        do get cache override ${attr} || fail_uncached ${attr}; say "${quiet}" -n . >&2
        done

        cat <<EOF

  ## On Hackage:

EOF
        for attr in $(filter_by_and ${predicate} test_is hackaged status)
        do get cache override ${attr} || fail_uncached ${attr}; say "${quiet}" -n . >&2
        done

        cat <<EOF

  ## Upstreamed

EOF
        for attr in $(filter_by_and ${predicate} test_is upstreamed status)
        do get cache override ${attr} || fail_uncached ${attr}; say "${quiet}" -n . >&2
        done

        cat <<EOF

  ## Unmerged

EOF
        for attr in $(filter_by_and ${predicate} test_is unmerged status)
        do get cache override ${attr} || fail_uncached ${attr}; say "${quiet}" -n . >&2
        done

        cat <<EOF

  ## Non-code, configuration-only change

EOF
        for attr in $(filter_by_and ${predicate} test_is config status)
        do get cache override ${attr} || fail_uncached ${attr}; say "${quiet}" -n . >&2
        done
        tracing_resume emit-overrides
}
  #+END_SRC
*** emit-overrides
  #+BEGIN_SRC sh
emit_overrides() {
        local emit_acme=
        local format=overrides
        local nixpkgs=
        local reuse_cache=
        local require_descs=
        local quiet=${NH_QUIET}
        local target=
        local desc=" "
        local output_hint=
        while test $# -ge 1
        do case "$1"
           in --emit-acme )            emit_acme="--emit-acme";;
              --format )               format=$2; shift;;
              --output-hint )          output_hint=$2; shift;;
              --reuse-cache )          reuse_cache="--reuse-cache";;
              --require-descs )        require_descs="--require-descs";;
              --quiet )                quiet="--quiet";;
              --target )               case "$2" in
                                           local )   target=$2; shift; desc=" local ";;
                                           nixpkgs ) target=$2; shift; desc=" Nixpkgs GHC configuration "; emit_acme="";;
                                           * ) fail "unexpected --target: '$2'";; esac;;
              --debug )                enable_debug;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        ###
        ### 1. Generate override cache
        ###
        if test -z "${reuse_cache}"
        then cache ${require_descs} ${quiet} "$@" ||
                 fail "cache generation failed"
        fi

        say "${quiet}" -n "Assembling${desc}overrides${output_hint:+ (in ${output_hint})}.." >&2
        ###
        ### 2. Emit overrides
        ###
        case ${format} in
        overrides )
                cat <<EOF
{ pkgs, haskellLib, super, self }:

with haskellLib; with self; {
EOF
                           ;;
        configuration-ghc )
                cat <<EOF
{ pkgs, haskellLib }:

with haskellLib;

self: super: {

EOF
                ghc_configuration_fixed_content;;
        * )
                fail "Unsupported --format for emit_overrides: '${format}'";;
        esac
        echo

        if test -z "${suppress_content}"
        then do_emit_overrides ${target:+--target ${target}}
        fi

        if test -n "${emit_acme}"
        then
                local tmpdir="$(mktemp -d)"
                cat <<EOF

  ## The catch-all attribute that depends on everything overridden (incl. meta/disabled things).
  ${ACME_ATTRIBUTE} = self.mkDerivation {
    pname = "${ACME_ATTRIBUTE}";
    version = "0.0.0";
    src = ${tmpdir};
    isLibrary = true;
    isExecutable = true;
    libraryHaskellDepends = [
      $(ls_acme_deps)
    ];
    license = stdenv.lib.licenses.bsd3;
  };
EOF
        fi
        if test -n "${EMIT_EXTRA_DEFS}" -a "${target}" = "local"
        then echo >&2
             echo "WARNING:  emitting extra definitions using 'nha':" >&2
             # nix-shell  -p haskell.packages.ghc841.nh --run "nha emit-extra-defn"
             nix-shell "${NIX_GHC_PACKAGE_SET}" -A nh --run "nha emit-extra-defn"
             # nha emit-extra-defn
        fi
        cat <<EOF
}
EOF
        say "${quiet}" " done." >&2
}
  #+END_SRC
*** apply
#+BEGIN_SRC sh
apply() {
        local tmp_ngo=$(mktemp  ${TMPDIR:-/tmp}/nh-overrides.XXXXXXXXXXXXX)
        local tmp_gcfp=$(mktemp ${TMPDIR:-/tmp}/nh-overrides.XXXXXXXXXXXXX)
        emit_overrides      --format overrides         ${TARGET_NIXPKGS:+--target local}                 --output-hint ${NIX_GHC_OVERRIDES}    ${NH_QUIET} "$@" > ${tmp_ngo}
        mv ${tmp_ngo} ${NIX_GHC_OVERRIDES}
        cp         -f ${NIX_GHC_OVERRIDES}    ${PKGDB}
        if test -n "${TARGET_NIXPKGS}"
        then emit_overrides --format configuration-ghc ${TARGET_NIXPKGS:+--target nixpkgs} --reuse-cache --output-hint ${GHC_CONFIG_FULL_PATH} ${NH_QUIET} "$@" > ${tmp_gcfp}
             mv ${tmp_gcfp} ${GHC_CONFIG_FULL_PATH}
             cp          -f ${GHC_CONFIG_FULL_PATH} ${PKGDB}
        fi
}
#+END_SRC
* Defining overrides
*** import-hackage-cabal
#+BEGIN_SRC sh
import_hackage_cabal() {
        local attr="$1"; shift
        echo "importing cabal package '${attr}'.."
        local url="$(hackage_cabal_upstream_url $attr || true)"
        if test -z "${url}"
        then fail "failed to detect upstream URL for '$attr'"; fi
        local chdir="$(hackage_cabal_chdir $attr || true)"

        local user= repo=
        if grep 'git@github.com:' <<< "${url}"
        then user="$(github_repo_gitssh_url_user ${url})"  repo="$(github_repo_gitssh_url_repo ${url})"
        else user="$(github_repo_githttp_url_user ${url})" repo="$(github_repo_githttp_url_repo ${url})"
        fi
        if test "${repo}" != "$(repoName "$attr")"
        then set_repoName "${attr}" "${repo}"
        fi
        set_upstream "${attr}" "${user}"
        if test -n "${chdir}"
        then _set def/meta chdir "${attr}" "${chdir}"
        fi
        info "$attr"
}
#+END_SRC
*** github
    #+BEGIN_SRC sh
github() {
        local attr="$1"; shift
        local user="${1:-$(upstream ${attr})}"
        local ref="$(iff refs/heads/$2 HEAD test -n "$2")"

        local repo=$(repoName ${attr})

        local REV="$(git ls-remote https://github.com/${user}/${repo} ${ref} | cut -f1)"
              REV="${REV:-$2}"
        if test "$(echo -n ${REV} | wc -c)" != 40
        then fail "ref '$2' is not known at https://github.com/${user}/${repo}"
        fi

        __EMPTY_REPO_HASH=0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5

        local QUIET_REDIR="$(iff '2>/dev/null' '' test -n "${NH_QUIET}")"
        local HASH=$(nix-prefetch-git https://github.com/${user}/${repo} --rev ${REV} --quiet ${QUIET_REDIR} | grep sha256 | cut -d'"' -f4 | tr -d '\n')

        if test "${HASH}" = "${__EMPTY_REPO_HASH}"
        then fail "zero repo hash.  Bad commit id?"
        fi

        _set def/github hash      $repo "${HASH}"
        _set def/github rev       $repo "${REV}"
        _set def/github user      $repo "${user}"
        _set def/github timestamp $repo  $(commit_timestamp "${attr}" "${REV}")
        _set def/over   src "$attr" github

        test -z "${NH_QUIET}" || cat <<EOF
- $(get def/github hash ${repo})
- https://github.com/${user}/${repo}/commit/$(get def/github rev ${repo})

EOF
}
#+end_src
*** hackage
    #+BEGIN_SRC sh
__EMPTY_HASH=0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5
hackage() {
        local PACKAGE="$1"; shift
        local RELEASE="$1"
        local QUIET_REDIR="$(iff '2>/dev/null' '' test -n "${NH_QUIET}")"
        local HASH="$(nix-prefetch-url https://hackage.haskell.org/package/${PACKAGE}-${RELEASE}.tar.gz ${QUIET_REDIR} | tr -d '\n')"

        if test "${HASH}" = "${__EMPTY_HASH}" -o -z "${HASH}"
        then fail "zero tarball hash.  Bad package name or version?"
        fi

        _set def/hackage hash    "$PACKAGE" "${HASH}"
        _set def/hackage release "$PACKAGE" "${RELEASE}"
        _set def/over    src     "$PACKAGE" hackage

        test -z "${NH_QUIET}" || cat <<EOF
  - $(get def/hackage hash ${PACKAGE})
  - https://hackage.haskell.org/package/${PACKAGE}-${RELEASE}

EOF
}
    #+END_SRC
*** promote-to-hackage
  #+BEGIN_SRC sh
promote_to_hackage() {
        local attr="$1"; shift
        local release="$1"
        local upstream_master_release="$2"

        if test_hackage_release "${upstream_master_release}" ${attr}
        then hackage ${attr} "${upstream_master_release}"
        else warn "AUTOMATIC FIX STALLED: github release version (${upstream_master_release}) has not been put on Hackage yet"
             echo -n "New Hackage release for ${attr}: "
             read release
             hackage ${attr} "${release}"
        fi
}
  #+END_SRC
* Building & Shelling
*** override-builder
#+BEGIN_SRC sh
override_builder() {
        local print_drv= quiet="${NH_QUIET}"
        while test $# -ge 1
        do case "$1"
           in --print-drv )            print_drv="--print-drv";;
              --quiet )                quiet="--quiet";;
              "--"* )                  fail "$0: unknown option: $1";;
              ,* )                      break;;
           esac
           shift
        done

        local attr="$1"; shift
        local over="$1"; shift

        ###
        ### 1. Instantiate
        ###
        local store_drv="$(do_instantiate ${attr})"
	local status=$?
	if test ${status} = 0 -a -n "${store_drv}"
	then
	        rm -f            ${PKGDB}/${DRVTY}/${attr}.${over}
	        ln -s $store_drv ${PKGDB}/${DRVTY}/${attr}.${over}
        	local store_src="$(attr_override_drv_src ${over} ${attr})"
	        rm -f            ${PKGDB}/${SRCTY}/${attr}.${over}
	        ln -s $store_src ${PKGDB}/${SRCTY}/${attr}.${over}
	else
		{ do_instantiate ${attr} 2>&1 || true; } |
    			set_stdin          ${LOGTY} ${over} ${attr}
                echo "FATAL: failed to instantiate '${attr}'$(iff "" ", without overriding '${over}'" test "${over}" = baseline)" >&2
                echo "FATAL: logs:  nh log ${attr} ${over}" >&2
                _set ${FAILTY}   ${over} ${attr} "INSTANTIATE"
                fail_classify_one_property ${over} ${attr}
		## TODO:  invoke the loop hunter?
                return 1
	fi

        ###
        ### 2. prebuild context (shell_for() gets you here)
        ###
        echo -n      "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-shell ${NIX_GHC_PACKAGE_SET} -A ${attr}.env ${NIX_BUILD_OPTIONS} 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        local status=${PIPESTATUS[0]}
        if test ${status} != 0
        then
                echo "FATAL: failed to prebuild deps of '${attr}'$(iff "" ", without overriding '${over}'" test "${over}" = baseline)" >&2
                echo "FATAL: drv: ${store_drv}" >&2
                local intermediate_failure=$(get ${LOGTY} "${over}" ${attr} | log_filter_failure)
		if test -n "${intermediate_failure}"
		then
                	echo "FATAL: ..apparently due to:  ${intermediate_failure}"
                	echo "FATAL: logs:  nh log ${attr} ${over}" >&2
		fi
                _set ${FAILTY}   ${over} ${attr} "DEPENDENCY/${intermediate_failure:-UNKNOWN}"
                fail_classify_one_property ${over} ${attr}
                return 1
        fi

        ###
        ### 3. build
        ###
        echo -n      "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-build ${NIX_GHC_PACKAGE_SET} -A ${attr} ${NIX_BUILD_OPTIONS} 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        ## Sadly the following doesn't create the output link, and stdout parsing is meh.
        # nix-store --realise ${store_drv} --cores 0 2>&1 \
        #         | set_stdin ${LOGTY} ${over} ${attr}
        status=${PIPESTATUS[0]}
        rm -f ${PKGDB}/current.build
        if test ${status} = 0
        then
                local drv=$(readlink result)
                rm -f result
                if test -n "${print_drv}"
                then echo $drv >&2
                fi
        else
                echo "FATAL: failed to build '${attr}'$(iff "" ", without overriding '${over}'" test "${over}" = baseline)" >&2
                echo "FATAL: drv: ${store_drv}" >&2
                local src_drv=$(nix_attr_drv_sdrv ${attr} ${store_drv})
                echo "FATAL: src.drv: ${src_drv}" >&2
                echo "FATAL: src URL: $(nix_src_drv_url ${src_drv})" >&2
                echo "FATAL: logs:  nh log ${attr} $(iff "" "${over}" test "${over}" = baseline)" >&2
                _set ${FAILTY}   ${over} ${attr} "DIRECT"
                fail_classify_one_property ${over} ${attr}
                return 1
        fi

        ###
        ### 3. build essential rdeps
        ###
        for erdep in $(get def/meta erdeps ${attr})
        do
                echo -n "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
                nix-build ${NIX_GHC_PACKAGE_SET} -A ${erdep} ${NIX_BUILD_OPTIONS} 2>&1 \
                        | set_stdin ${LOGTY} ${over} ${attr}
                status=${PIPESTATUS[0]}
                rm -f ${PKGDB}/current.build
                if test ${status} != 0
                then
                        echo "FATAL: essential rev-dependency '${erdep}' breaks$(iff "with baseline ${attr}" ", without overriding ${attr}'s '${over}'" test "${over}" = baseline)" >&2
                        echo "FATAL: logs:  nh get ${LOGTY} ${over} ${attr}" >&2
                        _set ${FAILTY} ${over} ${attr} "ESSENTIAL-REVERSE ${erdep}"
                        fail_classify_one_property ${over} ${attr}
                        return 1
                fi
        done
        _set ${SUCCTY}    ${over} ${attr} $drv
        _set ${FAILTY}    ${over} ${attr} ""
        _set ${FAILLOGTY} ${over} ${attr} ""
        _set ${FAILTYTY}  ${over} ${attr} ""
        return 0
}
#+END_SRC
*** with-field-value
    #+BEGIN_SRC sh
WFV_TYPE=
WFV_FIELD=
WFV_NAME=
WFV_SAVE_VAL=
with_field_value_atexit() {
        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${WFV_SAVE_VAL}"
        cache_gen_override_one "${WFV_NAME}"
}
with_field_value() {
        local update_cache=
        while test $# -ge 1
        do case "$1"
           in --debug )                enable_debug;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        WFV_TYPE="$1";    shift
        WFV_FIELD="$1";   shift
        WFV_NAME="$1";    shift
        local value="$1"; shift

        WFV_SAVE_VAL="$(get_def ${WFV_TYPE} ${WFV_FIELD} ${WFV_NAME} '')"
        # test ! -z "${SAVE_VAL}" || {
        #         echo "FATAL: '${OVER}' isn't specified for attribute  '${ATTR}'"
        #         exit 1
        # }

        trap with_field_value_atexit EXIT

        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${value}"
        cache_gen_override_one "${WFV_NAME}"

        "$@"
        local result=$?
        _set "${WFV_TYPE}" "${WFV_FIELD}" "${WFV_NAME}" "${WFV_SAVE_VAL}"
        cache_gen_override_one "${WFV_NAME}"
        return $result
}
    #+END_SRC
*** instantiate
    #+BEGIN_SRC sh
instantiate() {
        local reuse_cache= debug=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="reuse-cache";;
              --debug )                debug="--debug"; enable_debug;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if test -z "${reuse_cache}"
        then cache
        fi
        apply --reuse-cache ${debug}

        for attr in ${ATTRSET}
        do
                echo -n "EVAL ${attr}> "
                if ! do_instantiate ${attr}
                then fail "baseline breaks package:  ${attr}"
                fi
        done | tee ${PKGDB}/baseline.log
        return ${PIPESTATUS[0]}
}
    #+END_SRC
*** build
    #+BEGIN_SRC sh
build() {
        local limit_to_self= print_drv= reuse_cache= reuse_overrides= quiet=${NH_QUIET}
        while test $# -ge 1
        do case "$1"
           in --limit-to-self )        limit_to_self="--limit-to-self";;
              --print-drv )            print_drv="--print-drv";;
              --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --debug )                enable_debug;;
              --quiet )                quiet="--quiet";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done
        local _attr="$1"; shift
        local _over=${1:-baseline}

        if test -n "${limit_to_self}"
        then apply "${_attr}"
             ## XXX: leaks attr
             reuse_overrides="--reuse-overrides"
        fi
        coherently ${reuse_cache} ${reuse_overrides} ${quiet} ${_attr} "${_over}" override_builder ${print_drv} ${_attr} "${_over}"
}
    #+END_SRC
*** acme
#+BEGIN_SRC sh

acme() {
        local reuse_cache=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        if test -z "${reuse_overrides}"
        then apply ${reuse_cache} --emit-acme
        fi

        local attr=${ACME_ATTRIBUTE} over="default"
        echo "-( building ACME catch-all attribute that depends on everything overridden:"
        echo "--( < ${attr}"
        echo "--( > $(ls_acme_deps | xargs echo)"
        if test -n "$(ls_extra_validation_attributes)"
        then echo "--( ..of which non-overridden:  $(ls_extra_validation_attributes | xargs echo -n)"
        fi
        echo "---(             logs:  nh logs ${attr} ${over}"
        echo "---(    watch it live:  nh watch  --or--  nh progress"
        echo -n "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-shell ${NIX_GHC_PACKAGE_SET} -A ${attr} ${NIX_BUILD_OPTIONS} --no-out-link --keep-going 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        local status=${PIPESTATUS[0]}
        if test ${status} != 0
        then echo "-( things gone wrong:"
             # nh logs ${attr} ${over}
             get ${LOGTY} "${over}" ${attr} | log_filter_progress
        else echo "-( Peace.."
        fi
        return ${status}
}
#+END_SRC
*** baseline
#+BEGIN_SRC sh
baseline() {
        local reuse_cache= reuse_overrides=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if test -z "${reuse_overrides}"
        then apply ${reuse_cache}
        fi

        echo "-( validating baseline: all PKGDB overrides applied"
        for attr in ${ATTRSET}
        do
                echo -n "--("
                if ! build --reuse-overrides ${attr} "baseline"
                then fail "broken baseline package:  ${attr}"
                fi
        done | tee ${PKGDB}/baseline.log
        return ${PIPESTATUS[0]}
}
#+END_SRC
*** shell
    #+begin_src sh
shell() {
        apply --reuse-cache
        local attr=shell-environment over="default"

        echo -n "$(path ${LOGTY} ${over} ${attr})" > ${PKGDB}/current.build
        nix-shell ${NIX_BUILD_OPTIONS} --keep-going 2>&1 \
                | set_stdin ${LOGTY} ${over} ${attr}
        local status=${PIPESTATUS[0]}
        if test ${status} != 0
        then cat $(path ${LOGTY} ${over} ${attr}) >&2
             exit 1
        fi

        nix-shell "$@"
}
    #+END_SRC
*** shell-for
    #+begin_src sh
shell_for() {
        local _attr="$1"; shift
        apply --reuse-cache ${_attr}
        local over="default"

        nix-shell ${NIX_GHC_PACKAGE_SET} -A ${_attr}.env ${NIX_BUILD_OPTIONS} "$@"
}
    #+END_SRC
*** cabal-shell
  #+BEGIN_SRC sh
cabal_shell() {
        ## XXX:  ultra-messy/assumptiony
        # ATEXIT_REMOVE_FILES="default.nix shell.nix overrides.nix"
	# trap atexit_remove_files EXIT
        cabal2nix .         > default.nix
        if test         ! -f "shell.nix"
        then echo "Generating shell.nix.."
             emit_shell_nix > shell.nix
        fi
        shell "$@"
}
  #+END_SRC
*** fixer-shell
  #+BEGIN_SRC sh
fixer_shell() {
        local _attr="$1"; shift
        local upstream="$(upstream ${_attr})"
        local upstream_url="$(url upstream-github ${_attr})"
        local repo="$(repoName ${_attr})"

        github "${_attr}" "${upstream}"

        git clone ${upstream_url} ${repo}
        cd ${repo}
        set def/github user ${repo} ${GITHUB_USER}
        git remote add orig $(url self-github ${_attr})

        shell_for "${_attr}" --pure
}
  #+END_SRC
*** try-fix
  #+BEGIN_SRC sh
try_fix() {
        local attr="$1"; shift

        git push --force orig
        github "${attr}" "${GITHUB_USER}"
        build  --print-drv --limit-to-self --reuse-cache "${attr}"
}
  #+END_SRC
*** install
  #+BEGIN_SRC sh
install() {
        local attr="$1"; shift

        build ${attr}

}
  #+END_SRC
* Maintenance, Trimming & Audit
*** trim-override
  #+BEGIN_SRC sh
trim_override() {
        local attr="$1"; shift
        local over="$1"; shift

        echo -n "TRIM ${attr} -${over}>  "
        if ! with_field_value def/over "${over}" "${attr}" ""     coherently --reuse-cache ${attr} "${over}" override_builder ${attr} ${over}
        then echo "FAILED"
        elif has def/meta "${over}.explanation" "${attr}"
        then echo "OK-BUT, explanation exists:  nh x emit_explanation ${over} ${attr}"
        else echo "OK: $(get ${SUCCTY} ${over} ${attr})"
        fi
}
  #+END_SRC
*** trim-attribute
  #+BEGIN_SRC sh
trim_attribute() {
        local attr="$1"; shift

        echo -n "TRIM ${attr} -all>  "
        if   with_field_value def/meta "disable" "${attr}" "true" coherently --reuse-cache ${attr} "default" override_builder ${attr} "default"
        then echo "OK: $(get ${SUCCTY} default ${attr})"
        else echo "FAILED"
        fi

        for  over in $(lsattrs def/over ${attr})
        do trim_override ${attr} ${over}
        done
        for iover in $(lsiovers         ${attr})
        do trim_override ${attr} input.${iover}
        done
}
  #+END_SRC
*** trim
#+BEGIN_SRC sh
trim() {
        local reuse_cache= since=
        while test $# -ge 1
        do case "$1"
           in --reuse-cache )          reuse_cache="--reuse-cache";;
              --since )                since="$2"; shift;;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then if test -z "${since}"
	     then echo "Full trimming requested, resetting state"
                  reset_computed_state
                  ATTRSET="$(_ls def/over)"
	     else ATTRSET="$(_ls def/over | sed -ne "/^${since}/,$ p")"
             fi
        fi

        if test -z "${reuse_cache}"
        then cache
        fi
        cache_copy override trim

        echo "-( trimming in progress"
        for attr in ${ATTRSET}
        do if ! test_overrides_disabled ${attr}
           then echo "TRIM ${attr}> "
                trim_attribute ${attr}
           fi
        done | tee ${PKGDB}/trim.log
        apply
}
#+END_SRC
*** show-trims
#+BEGIN_SRC sh
show_trims() {
        for attr in $(_ls ${SUCCTY})
        do
                local trimset="$(lsattrs ${SUCCTY} ${attr} | xargs echo -n)"
                if test "${trimset}" = "default"
                then trimset="$(lsattrs def/over ${attr} | xargs echo -n)"
                fi

                for over in ${trimset}
                do if has  def/meta ${over}.explanation ${attr}
                   then echo "KEEP ${attr}.${over}>  it has an explanation"
                   else echo "TRIM>  ${attr}.${over}"
                   fi
                done
        done
}
    #+END_SRC
*** execute-trims
  #+BEGIN_SRC sh
execute_trims() {
        for attr in $(_ls ${SUCCTY})
        do
                local trimset="$(lsattrs ${SUCCTY} ${attr} | xargs echo -n)"
                if test "${trimset}" = "default"
                then
                        echo "--( ${attr} now entirely redundant"
                        trimset="$(lsattrs def/over ${attr} | xargs echo -n)"
                fi

                echo "--( ${attr} trimmable: ${trimset}"
                for over in ${trimset}
                do if ! has  def/meta ${over}.explanation ${attr}
                   then _set def/over ${over} ${attr} ""
                   else echo "---( keeping ${over}, since it has an explanation"
                   fi
                done
        done
}
  #+END_SRC
*** attrs-suggested-by-trim
  #+BEGIN_SRC sh
attrs_suggested_by_trim() {
        local attr=$1; shift
        for over in $(lsattrs def/over ${attr})
        do if test_suggested_by_trim ${over} ${attr}
           then echo ${over}
           fi
        done
}
  #+END_SRC
*** audit-one
    #+BEGIN_SRC sh
warn() {
        local x="$1"
        local msg="$2"
        printf "%32s: $msg\n" "$x"
}
audit_one() {
        local autofix= autoonly=
        while test $# -ge 1
        do case "$1"
           in --autofix ) autofix=yes-please;;
              --autoonly ) autoonly=yes-please;;
              "--"* )     fail "$0: unknown option: $1";;
              * )         break;;
           esac
           shift
        done

        local attr="$1"; shift

	if has def/meta disable ${attr}
        then warn "${attr}" "disabled"
             return 0
        fi

        local overrides="$(lsattrs def/over ${attr})"

        ## 1. Proof of necessity exists
        local status=0
        for over in ${overrides}
        do if ! emit_explanation ${over} ${attr} >/dev/null
           then
			warn      "${attr}.${over}" "no proof:  nh x emit_explanation ${over} ${attr}"; status=1
			if test_suggested_by_trim ${over} ${attr}
			then warn "${attr}.${over}" "*** already suggested for trimming ***"
			else warn "${attr}.${over}" "retrim:    nh trim --skip-baseline ${attr}"
			fi
           fi
        done

        local repo="$(repoName ${attr})"
        if ! has def/github upstream ${repo}
        then warn ${attr} "no upstream specified"
        fi

        if echo ${overrides} | grep -qw "src"
        then
        case $(status ${attr}) in
        shadowed )    
                ## Proof-of-existence checks are only things the come to mind.
                true;;
        hackaged )
                ## 1. Nixpkgs ought to be behind: nixpkgs release != upstream release (should be stricter: <)
                local nixpkgs_release=$(get_nixpkgs_release ${attr})
                local upstream_release=$(get_upstream_release ${attr})
                if test -z "$nixpkgs_release" -o -z "$upstream_release"
                then
                        warn "${attr}" "release versions odd: upstream $upstream_release, nixpkgs $nixpkgs_release"
                elif V "${nixpkgs_release}" '>=' "${upstream_release}"
                then
                         warn "${attr}" "nixpkgs release not behind upstream: ${nixpkgs_release}"; status=1
                         if test -n "${autofix}"
                         then warn "NOT AUTOMATICALLY FIXABLE: remove the src override"; set -x
                              _set def/over src ${attr} ""
                              set +x
                         fi
                fi
                ;;
        upstreamed )
                ## Upstreamed and unreleased:
                ## 1. internal checks: upstream and PR are specified and github user is upstream
                ## 2. upstream master is not ahead upstream override rev, version-wise
                ## 3. upstream release is not on hackage yet
                local repo="$(repoName ${attr})"
                if ! has def/github upstream ${repo}
                then
                        warn "${attr}/${repo}" "github upstream not specified"; status=1
                        if test -n "${autofix}" -a -z "${autoonly}"
                        then
                                warn "MANUAL FIX: supply missing upstream"
                                echo -n "New upstream github username for ${attr}: "
                                read upstream
                                _set def/github upstream ${attr} "${upstream}"
                        fi
                elif ! test_upstreamed ${attr}
                then
                        warn "${attr}" "github user '$(get def/github user $repo)' != upstream '$(get def/github upstream $repo)'"; status=1
                        if test -n "${autofix}"
                        then warn "NOT FIXABLE: internal consistency violation"
                        fi
                #else echo "test_upstreamed ${attr}"
                fi
                local override_rev=$(get def/github rev ${repo})
                local upstream_master_release=$(  get_upstream_release ${attr} "master")
                local upstream_override_release=$(get_upstream_release ${attr} ${override_rev})
                if V "${upstream_master_release}" '>' "${upstream_override_release}"
                then
                        if test_hackage_release "${upstream_master_release}" ${attr}
                        then
                                warn "${attr}" "upstream master: ${upstream_master_release}, upstream override: ${upstream_override_release}"; status=1
                                if test -n "${autofix}"
                                then warn "AUTOMATIC FIX: promote src override from github to hackage"
                                        promote_to_hackage ${attr} "${release}" "${upstream_master_release}"
                                fi
                        else
                                warn "${attr}" "upstream master: ${upstream_master_release}, upstream override: ${upstream_override_release} BUT upstream master's version (${upstream_master_release}) is not yet on Hackage"; status=1
                       fi
                elif hackage_ahead_of_fix ${attr}
                then
                       local release=${upstream_master_release}
                       local reldate="$(hackage_release_date ${attr} ${release})"
                       local fixstamp="$(fix_timestamp ${attr})"
                       local fixdate="$(date -d @${fixstamp})"
                       warn "${attr}" "hackage ${release} obsoletes upstream fix (version ${upstream_override_release}), committed ${fixdate} < release uploaded ${reldate}"
                       if test -n "${autofix}"
                       then warn "AUTOMATIC FIX: promote src override from github to hackage"
                               promote_to_hackage ${attr} "${release}" "${release}"
                       fi
                # else echo "${attr}: ${upstream_master_release} == ${upstream_override_release}"
                fi
		;;
        unmerged )
                ## Prefer upstream:
                ## 1. no Hackage release,
                ## 2. PR available,
                ## 3. PR not merged
                local user_release=$(get_user_release ${attr})
                local upstream_release=$(get_upstream_release ${attr})
                if test -n "${user_release}" -a "${user_release}" != "${upstream_release}"
                then
                        if test_hackage_release "${upstream_release}" ${attr}
                        then
                                warn "${attr}" "upstream: ${upstream_release}, user: ${user_release}:  nh hackage ${attr} ${upstream_release}"; status=1
                                if test -n "${autofix}"
                                then warn "AUTOMATIC FIX: promote src override from github to hackage"
                                     promote_to_hackage ${attr} "${release}" "${upstream_release}"
                                fi
                        else
                                warn "${attr}" "upstream: ${upstream_release}, user: ${user_release} BUT upstream's version (${upstream_release}) is not yet on Hackage"; status=1
                        fi
                # else echo "${attr}: ${user_release} == ${upstream_release}"
                fi
                local repo="$(repoName ${attr})"
                local pr=$(get_def def/github pr ${repo} "")
                if   test -z "${pr}"
                then
                        warn "${attr}" "no upstream PR: _set def/github pr ${repo}"; status=1
                        if test -n "${autofix}" -a -z "${autoonly}"
                        then warn "MANUAL FIX: supply missing PR #"
                             echo -n "New upstream PR # for ${attr}: "
                             read pr
                             _set def/github pr ${repo} "${pr}"
                        fi
                elif test "$(pull_request_status ${attr})" = merged
                then
                        warn "${attr}" "PR ${pr} was merged upstream"
                        if test -n "${autofix}"
                        then warn "AUTOMATIC FIX: promote src override to upstream"
                             github "$(repo_upstream ${repo})" ${attr}
                        fi
                #else echo "${attr}: PR: $(url upstream-pull-request ${attr})"
                fi;;
        config )
                ## Proof of necessity (at the top of the file) suffices.
                true;;
        * )
                fail "$0: unhandled status '$(status ${attr})' of attribute ${attr}";;
        esac
        fi

        return $status
}
#+END_SRC
*** audit
#+BEGIN_SRC sh
audit() {
        local skip_baseline= reuse_cache= reuse_overrides= autofix=
        while test $# -ge 1
        do case "$1"
           in --skip-baseline )        skip_baseline="--skip-baseline";;
              --reuse-cache )          reuse_cache="--reuse-cache";;
              --reuse-overrides )      reuse_overrides="--reuse-overrides";;
              --autofix )              autofix="--autofix";;
              "--"* )                  fail "$0: unknown option: $1";;
              * )                      break;;
           esac
           shift
        done

        local ATTRSET="$*"
        if test -z "${ATTRSET}"
        then ATTRSET="$(_ls def/over)"
        fi

        if   test -z "${skip_baseline}"
        then baseline  ${reuse_cache} ${reuse_overrides}
        elif test -z "${reuse_overrides}"
        then apply     ${reuse_cache}
        fi

        for attr in ${ATTRSET}
        do audit_one ${autofix} ${attr} || true
        done | tee ${PKGDB}/audit.log
}
#+END_SRC
*** loop-hunter
#+BEGIN_SRC sh
loop_hunter() {
        local marker="infinite recursion encountered, at undefined position"
        local stdin="$(cat | log_filter_evaluation_failure_attributes "\|${marker}" | grep -v '^interactive-.*-environment$' | sed 's/\([a-zA-Z0-9-]*\)-[0-9].*$/\1/')"
        if ! echo $stdin | grep -q "${marker}"
        then echo "No loops detected"; return 0
        fi

        local loop_attributes="$(echo $stdin | sed "s/${marker}//")"
        echo "Found a loop with attributes: $loop_attributes"

        cache
        for x in $loop_attributes
        do echo "EVAL +doCheck ${x}>  with_field_value def/over doCheck $x false instantiate --reuse-cache $x"
           if with_field_value def/over doCheck "$x" false instantiate --reuse-cache "$x"
           then echo "OK +doCheck> ${x}"
           else echo "FAIL +doCheck> ${x}"
           fi
        done
}
#+END_SRC
* Help system
#+BEGIN_SRC sh
print_command_help() {
        local width=25 len=$(echo -n "$1" | wc -c)
        if test ${len} -gt ${width}
        then printf "   %s\n                             %s\n" "$1" "$2"
        else printf "   %-${width}s %s\n" "$1" "$2"
        fi
        return 1
}
alias HELP='test "$1" != --help || print_command_help '
shopt -s expand_aliases
section() {
        local section_title="$1"; shift
cat <<EOF

  ${section_title}:

EOF
        for x in "$@"
        do command_dispatch "${x%% *}" --help
        done
}

print_help() {
cat <<EOF
Usage:  nh [--cls] [--nixpkgs] [--trace] [--debug] [--quiet] SUBCMD [SUBARGS..]

NOTE:  if --nixpkgs is passed, non-local overrides instead serve as definition
       for ${GHC_CONFIG_FULL_PATH}

EOF
        for x in "$@"
        do command_dispatch section-$x
        done
        echo
}
#+END_SRC
* Argument parsing
#+begin_src sh
while test $# -ge 1
do case "$1"
   in --cls )              echo -en "\ec";;
      --nixpkgs )          TARGET_NIXPKGS="--nixpkgs";;
      --quiet | -q )       NH_QUIET="--quiet";;
      --trace )            set -x; NH_TRACING=true;;
      --traceless | -t )   shift; "$0" --trace "$@" 2>&1 | less;;
      --full-trace )       set -x;;
      --help | -h )        $0 help;;
      --debug )            enable_debug
                           # Unfortunately, this cannot work in general, because of the broken 'return 1' handling:
                           shopt -s extdebug
                           trap 'errexit' ERR # trap ERR to provide an error handler whenever a command exits nonzero this is a more verbose version of set -o errexit
                           set -o errtrace    # setting errtrace allows our ERR trap handler to be propagated to functions,  expansions and subshells
                           ;;
      "--"* )              fail "$0: unknown option: $1";;
      * )                  break;;
   esac
   shift
done

#+end_src
* Top level: basic override manipulation and queries
#+begin_src sh
command_dispatch() {

        local command="$1"; shift 2>/dev/null || true
        case "${command}" in
help | "" )        print_help general pkgdb meta overman status nix cabal github overhigh build maintain generate miscellanea;;

#+end_src
*** General
#+begin_src sh :var title=(org-tangle-item)
section-general )
section "${title}" ls info overview;;

ls )               HELP "ls [REGEX]"               "List all overridden attributes" || return 0
                   _ls | grep "$1" || true;;

info | show )      HELP "info ATTR"                "Overview of an attribute's PKGDB" || return 0
                   info "$1";;

overview )         HELP "overview [ATTR..]"        "List overridden attributes, grouped by status + relevant info" || return 0
                   overview "$@";;
#+end_src
*** PKGDB
#+BEGIN_SRC sh :var title=(org-tangle-item)
section-pkgdb )
section "${title}" forall-defined-edit;;

forall-defined-edit ) HELP "forall-defined-edit TYPE FIELD" "Interactively edit all FIELD definitions of TYPE" || return 0
                   forall_defined_edit $1 $2;;

#+END_SRC
*** Metadata (non-override)
#+begin_src sh :var title=(org-tangle-item)
section-meta )
section "${title}" ls-meta meta set-meta edit-meta disable enable set-explanation set-erdeps chdir local nonlocal;;

ls-meta )          HELP "ls-meta ATTR"             "List attribute's metadata (as opposed to overrides" || return 0
                   lsattrs def/meta  "$1";;

meta )             HELP "meta ATTR META"           "Print a single metadata entry of an attribute" || return 0
                   get     def/meta  "$2" "$1";;

set-meta )         HELP "set-meta ATTR META VAL"   "Set a single metadata entry of an attribute" || return 0
                   _set    def/meta  "$2" "$1" "$3";;

edit-meta )        HELP "edit-meta ATTR META"      "Edit the current attribute's meta value using readline" || return 0
                   edit    def/meta  "$2" "$1";;

disable )          HELP "disable ATTR[.OVER]"     "Disable all/single overrides for an attribute" || return 0
                   local attr="$1" over="${2:+.$2}"
                   _set       def/meta disable${over} "$attr" true
                   apply "$1";;

enable )           HELP "enable ATTR[.OVER]"      "Re-enable previously disabled overrides" || return 0
                   local attr="$1" over="${2:+.$2}"
                   _set       def/meta disable${over} "$attr" ""
                   apply "$1";;

set-explanation )  HELP "set-explanation ATTR OVER" "Provide a manual explanation for an override's existence" || return 0
                   local attr="$1" over="$2"
		   edit "def/meta" "${over}".explanation "${attr}";;

set-erdeps )       HELP "set-erdeps ATTR 'ATTR..'" "Set attribute's essential rev-deps that must keep working" || return 0
                   local attr="$1"; shift
                   local erdeps="$*"
		   _set def/meta erdeps "${attr}" "${erdeps}";;

chdir )            HELP "chdir ATTR SUBDIR"        "Change directory before build;  \"\" removes the override" || return 0
                   _set    def/meta chdir   "$1" "$2"
                   apply "$1";;

local )            HELP "local ATTR"               "Mark ATTR as local: not subject for Nixpkgs GHC configuration" || return 0
                   _set    def/meta local   "$1" true;;

nonlocal )         HELP "nonlocal ATTR"            "Remove marking of ATTR as local" || return 0
                   _set    def/meta local   "$1" "";;

#+end_src
*** Override manipulation (low level)
  #+begin_src sh :var title=(org-tangle-item)
section-overman )
section "${title}" \
         remove ls-over ls-input-overs get set edit \
         dontRevision check dontCheck haddock dontHaddock jailbreak dontJailbreak libraryHaskell;;

remove )           HELP "remove ATTR[.OVER]"      "Remove specified overrides" || return 0
                   local attr="$1" over="${2:+.$2}"
                   remove "${attr}" "${over}"
                   apply "${attr}";;

ls-over )          HELP "ls-over ATTR"            "List attribute's overrides" || return 0
                   lsattrs def/over              "$1";;

lsio | lsiovers | ls-input-overs )
                   HELP "ls-input-overs ATTR"     "List attribute's input overrides" || return 0
                   lsiovers def/over             "$1";;

get )              HELP "get ATTR OVER"           "Get an attribute's override value" || return 0
                   get  def/over "$2"            "$1";;

set )              HELP "set ATTR OVER VAL"       "Set an attribute's override value;  \"\" removes the override" || return 0
                   _set def/over "$2"            "$1" "$3"; apply "$1";;

edit )             HELP "edit ATTR OVER"          "Edit the current attribute's value using readline" || return 0
                   edit def/over                 "$2" "$1";   apply "$1";;

setio | set-iover | set-input-over )
                   HELP "set-input-over ATTR INPUT VAL" \
                                                  "Set ATTR's override for INPUT" || return 0
                   set_iover "$1" "$2" "$3";;

dr | dontRevision )     HELP "edit ATTR OVER"          "Edit the current attribute's value using readline" || return 0
                   _set def/over revision        "$1" "null"
                   _set def/over editedCabalFile "$1" "null"; apply "$1";;

check | doCheck )  HELP "check ATTR"              "Disable an existing dontCheck override" || return 0
                   _set def/over doCheck         "$1";        apply "$1";;

dc | dontCheck )        HELP "dontCheck ATTR"          "Disable tests" || return 0
                   _set def/over doCheck         "$1" false;  apply "$1";;

haddock | doHaddock )
                   HELP "haddock ATTR"            "Disable an existing dontHaddock override" || return 0
                   _set def/over doHaddock       "$1";        apply "$1";;

dh | dontHaddock )      HELP "dontHaddock ATTR"        "Disable Haddock generation" || return 0
                   _set def/over doHaddock       "$1" false;  apply "$1";;

j | jailbreak | doJailbreak )
                   HELP "jailbreak ATTR"          "Turn on jailbreaking" || return 0
                   _set def/over jailbreak       "$1" true;   apply "$1";;

dontJailbreak )    HELP "dontJailbreak ATTR"      "Disable an existing jailbreak override" || return 0
                   _set def/over jailbreak       "$1";        apply "$1";;

libraryHaskell )
                   HELP "libraryHaskell ATTR [ATTR..]" \
                                                  "Specify extra libraryHaskellDepends;  \"\" removes the override" || return 0
                   local attr="$1"; shift
                   _set def/over libraryHaskell   "$attr" "$*";   apply "$attr";;
#+end_src
*** Status
  #+begin_src sh :var title=(org-tangle-item)
section-status )
section "${title}" status ls-shadowed ls-hackaged ls-upstreamed ls-unmerged ls-config;;

status )           HELP "status ATTR"            "Print status of a single attribute" || return 0
                   echo "$1: $(status $1)";;

ls-shadowed )      HELP "ls-shadowed"            "List all attributes with status 'shadowed'" || return 0
                   filter test_is shadowed   status;;

ls-hackaged )      HELP "ls-hackaged"            "                             ...'hackaged'" || return 0
                   filter test_is hackaged   status;;

ls-upstreamed )    HELP "ls-upstreamed"          "                             ...'upstreamed'" || return 0
                   filter test_is upstreamed status;;

ls-unmerged )      HELP "ls-unmerged"            "                             ...'unmerged'" || return 0
                   filter test_is unmerged   status;;

ls-config )        HELP "ls-config"              "                             ...'config'" || return 0
                   filter test_is config     status;;
#+end_src
*** Nix-level inferences
  #+begin_src sh :var title=(org-tangle-item)
section-nix )
section "${title}" drv ppdrv src src-drv src-url inputs dependencies referrers realise drv-pprint src-drv src-drv-url drv-inputs drv-refs deriver-of;;

drv )              HELP "drv ATTR"                          "Store derivation for a single override" || return 0
                   local attr="$1"
                   do_instantiate ${attr};;

ppdrv | pp-drv | pprint-drv )
                   HELP "pprint-drv ATTR"                   "Pretty-print ATTR's derivation (requires nix-derivation-pretty)" || return 0
                   local attr="$1"
                   pp-drv $(do_instantiate ${attr});;

src )              HELP "src ATTR"                          "Store source derivation for a single override" || return 0
                   local attr="$1"
                   nix_drv_src $(do_instantiate ${attr});;

sdrv | src-drv )   HELP "src-drv ATTR"                      "Store source derivation of ATTR" || return 0
                   local attr="$1"
                   nix_attr_drv_sdrv "${attr}" $(do_instantiate ${attr});;

surl | src-url )   HELP "src-url ATTR"                      "Source URL of ATTR" || return 0
                   local attr="$1"
                   nix_src_drv_url $(nix_attr_drv_sdrv "${attr}" $(do_instantiate ${attr}));;

in | inputs )
                   HELP "inputs ATTR"                       "ATTR's store inputs" || return 0
                   local attr="$1"
                   local drv="$(do_instantiate ${attr})"
                   nix_drv_inputs "${drv}";;

deps | dependencies | refs | references )
                   HELP "deps | refs | references ATTR"     "ATTR's store drv dependencies" || return 0
                   local attr="$1"
                   do_instantiate ${attr} | xargs nix-store --query --references;;

rdeps | referrers )
                   HELP "rdeps | referrers ATTR"            "ATTR's store reverse drv dependencies" || return 0
                   local attr="$1"
                   do_instantiate ${attr} | xargs nix-store --query --referrers;;

r | realise | realise-drv )
                   HELP "realise-drv ATTR"                  "Realise ATTR's derivation" || return 0
                   local attr="$1"
                   do_instantiate ${attr} | xargs nix-store --realise;;

dpp | drv-pprint ) HELP "drv-pprint STORE-DRV"              "Pretty-print a Nix-stored .drv file" || return 0
                   local drv="$1"
                   pp-drv ${drv};;

sdrv | src-drv )   HELP "src-drv STORE-DRV"                 "Store source derivation for a Nix-stored .drv file" || return 0
                   local drv="$1"
                   nix_drv_src ${drv};;

sdurl | src-drv-url )
                   HELP "src-drv-url STORE-DRV"             "Source URL of a Nix-stored source-.drv file" || return 0
                   local drv="$1"
                   nix_src_drv_url "${drv}";;

din | drv-inputs )
                   HELP "drv-inputs STORE-DRV"              "Store inputs for a Nix-stored .drv file" || return 0
                   local drv="$1"
                   nix_drv_inputs "${drv}";;

ddeps | drefs | drv-refs | drv-references )
                   HELP "drv-refs | drv-references STORE-DRV" "Store .drv references for a Nix-stored .drv file" || return 0
                   local drv="$1"
                   nix-store --query --references ${drv};;

dof | deriver | deriver-of )
                   HELP "deriver-of STORE-PATH"             "Store .drv for a Nix store path.  Will fail if built non-locally" || return 0
                   local path="$1"
                   nix-store --query --deriver ${path};;

#+end_src
* Top level: defining overrides
*** Cabal-related
#+begin_src sh :var title=(org-tangle-item)
section-cabal )
section "${title}" import cabal;;

import | import-cabal )
                   HELP "import ATTR"                            "Scrape ATTR's Cabal file from Hackage for some properties" || return 0
                   local attr="$1"
                   import_hackage_cabal "$1";;

cabal | cabal-release )
                   HELP "cabal ATTR"                             "Print the latest released cabal file for ATTR" || return 0
                   hackage_cabal "$1";;
#+end_src
*** Github-based overrides
#+begin_src sh :var title=(org-tangle-item)
section-github )
section "${title}" github set-upstream edit-upstream set-pr set-issue set-repoName edit-repoName;;

g | github )
                   HELP "github ATTR [REF]"                      "Override ATTR to its latest upstream Github commit" || return 0
                   local attr="$1"; shift
                   local ref="$1"
                   local repo=$(repoName ${attr})
                   github "$attr" "$(get def/github user $repo)" ${ref}
                   apply  "$attr";;

set-upstream )     HELP "set-upstream ATTR GITHUB-USER"          "Specify an attribute's Github upstream username" || return 0
                   local attr="$1" upstream="$2"
                   set_upstream "${attr}" "${upstream}"
                   apply "$attr";;

edit-upstream )    HELP "edit-upstream ATTR"                     "Edit an attribute's Github upstream username" || return 0
                   local attr="$1"
                   edit_upstream "${attr}"
                   apply "$attr";;

set-pr )           HELP "set-pr ATTR PR#"                        "Set the PR# of an attribute's Github override" || return 0
                   local attr="$1" pr="$2"
                   if test_is unmerged status "$attr"
                   then _set def/github pr "$(repoName "$attr")" "$pr"
                   else fail "not unmerged: $attr"
                   fi
                   apply "$attr";;

set-issue )        HELP "set-issue ATTR ISSUE#"                  "Set the Issue# of an attribute's Github override" || return 0
                   local attr="$1" issue="$2"
                   _set def/github issue "$(repoName "$attr")" "$issue"
                   apply "$attr";;

set-repoName )     HELP "set-repoName ATTR REPO"                 "Set an attribute's Github repository name" || return 0
                   local attr="$1" repo="$2"
                   set_repoName "$attr" "$repo"
                   apply "$attr";;

edit-repoName )    HELP "edit-repoName ATTR"                     "Edit an attribute's Github repository name" || return 0
                   local attr="$1"
                   edit_repoName "$attr"
                   apply "$attr";;
#+end_src
*** Override manipulation (high-level)
  #+begin_src sh :var title=(org-tangle-item)
section-overhigh )
section "${title}" hackage unmerged upstream;;

h | hackage )	   HELP "hackage ATTR [RELEASE=upstream-latest]" "Override to a Hackage release" || return 0
                   local attr="$1"
                   local release="${2:-$(get_upstream_release ${attr})}"
                   hackage "$attr" "$release"
                   apply "$attr";;

unmerged )	   HELP "unmerged ATTR USER PR# [REV=HEAD]"      "Override to a 3rd-party Github commit" || return 0
                   local attr="$1" user="$2" pr="$3" rev="$4"
                   test -n "$attr" -a -n "$user" -a -n "pr" ||
                           fail "Usage: $0 unmerged ATTR GH-USER PR-ID [GITREV]"
                   github "$attr" "$user" "$rev"
                   _set def/github pr "$(repoName "$attr")" "$pr"
                   apply "$attr";;

upstream )	   HELP "upstream ATTR [REV=HEAD]"               "Override to an upstream Github commit" || return 0
                   local attr="$1" rev="$2"
                   local repo=$(repoName ${attr})
                   local user=$(get def/github upstream $repo)
                   github "$attr" "$user" "$rev"
                   apply "$attr";;
#+end_src
* Top level: building & maintaining attributes
*** Build & results
  #+begin_src sh :var title=(org-tangle-item)
section-build )
section "${title}" build log fail failure-log failure-type proof;;

b | build )        HELP "build [COMMON-OPTS] ATTR"          "Build a single attribute with current overrides" || return 0
                   build --print-drv --limit-to-self "$@";;

log | logs )       HELP "log ATTR [OVER=baseline]"          "Obtain trim build logs for a single override" || return 0
                   local attr="$1" over="${2:-baseline}"
                   get ${LOGTY}      "${over}" ${attr};;

fail | failure )   HELP "failure ATTR [OVER=baseline]"      "Obtain trim failure kind of an override" || return 0
                   local attr="$1" over="${2:-baseline}"
                   get ${FAILTY}     "${over}" ${attr};;

faillog | failure-log )
                   HELP "failure-log ATTR [OVER=baseline]"  "Obtain trim failure log of an override" || return 0
                   local attr="$1" over="$2"
                   faillog           "${over}" ${attr};;

failty | failtype | failure-type )
                   HELP "failure-type ATTR [OVER=baseline]" "Obtain trim failure type of an override" || return 0
                   local attr="$1" over="${2:-baseline}"
                   get ${FAILTYTY}   "${over}" ${attr}; echo;;

proof )            HELP "proof ATTR [OVER]" "Print an override's proof of necessity. When OVER is empty, print context." || return 0
                   local attr="$1" over="$2"
                   emit_explanation "${over}" "${attr}";;
#+end_src
*** Override database maintenance
  #+begin_src sh :var title=(org-tangle-item)
section-maintain )
section "${title}" instantiate acme baseline trim trim-override show-trims execute-trims audit extra-validation-attributes;;

instantiate )      HELP "instantiate [--reuse-cache] [ATTR..]" "Instantiate overridden attrs (or specified subset)" || return 0
                   instantiate "$@";;

acme )
                   HELP "acme [--reuse-cache]" "Build everything at once, collecting all failures" || return 0
                   acme "$@";;

baseline )         HELP "baseline [--reuse-{overrides,cache}] [ATTR..]" "Build overridden attrs (or specified subset)" || return 0
                   baseline "$@";;

trim )             HELP "trim [--reuse-cache] [ATTR..]" \
                           "Suggest a reduction to the override set (or specified subset)" || return 0
                   trim "$@";;

trim-override )    HELP "trim-override ATTR OVER" "Attempt trimming a specific override of a given attribute" || return 0
                   trim_override "$@";;

show-trims )       HELP "show-trims" "Show the trim suggestion" || return 0
                   show_trims "$@";;

apply-trim | apply-trims | execute-trims )
                   HELP "execute-trims" "Execute the suggestion" || return 0
                   execute_trims "$@"
                   apply;;

audit )            HELP "audit [--autofix] [--autoonly] [--skip-baseline] [--reuse-{overrides,cache}] [ATTR..]" \
                           "Sanity check the overridden attrs (or specified subset).  --autofix applies suggestions" || return 0
                   audit "$@";;

extra-validation-attributes )
                   HELP "extra-validation-attributes" "Edit the set of attributes validated regardless of being overridden" || return 0
                   edit def/meta extra-validation-attributes "";;
#+end_src
*** Generation of overrides
  #+begin_src sh :var title=(org-tangle-item)
section-generate )
section "${title}" over apply cache show-cache;;

o | over | override | show-override )
                   HELP "over | override | show-override ATTR" \
                           "Print the attribute's override defined by PKGDB" || return 0
                   emit_override "$1";;

a | overrides | apply )
                   HELP "apply [--reuse-cache]" \
                           "Apply all overrides via ${NIX_GHC_OVERRIDES}" || return 0
                   apply "$@";;

cache )            HELP "cache [--require-descs]" \
                           "Regenerate override cache" || return 0
                   cache "$@";;

show-cache )       HELP "show-cache ATTR"      "Print the cached text of attribute's override (DEBUG)" || return 0
                   get cache override "$1";;
#+end_src
* Using overrides
*** Nix shell
#+begin_src sh :var title=(org-tangle-item)
section-shell )
section "${title}" shell shell-for cabal-shell fixer-shell try-fix module pkg describe modules phases;;

s | shell )
                   HELP "shell"                "Nix shell with up-to-date overrides (shell.nix required)" || return 0
                   shell "$@";;

sf | shfor | shell-for )
                   HELP "shell-for ATTR"       "Nix shell for building ATTR" || return 0
                   shell_for "$@";;

c | cabsh | cabal-shell )
                   HELP "cabal-shell"          "Nix shell from a cabal file (nothing else required)" || return 0
                   cabal_shell "$@";;

f | fish | fixer-shell )
                   HELP "clone-upstream-fixer-shell" \
                                               "Nix shell from a cabal file (nothing else required)" || return 0
                   fixer_shell "$@";;

try | try-fix )
                   HELP "try-fix ATTR"         "Push the current commit and try the fix" || return 0
                   try_fix "$@";;

mod | module | find-module )
                   HELP "find-module NAME"     "Convenience alias for 'ghc-pkg find-module NAME'" || return 0
                   local module="$1"; shift
                   ghc-pkg find-module ${module};;

lspk | pkg | list-packages )
                   HELP "list-packages ..."    "Convenience alias for 'ghc-pkg list ..." || return 0
                   ghc-pkg list "$@";;

desc | describe | describe-package )
                   HELP "describe-package ATTR" "Convenience alias for 'ghc-pkg describe ATTR" || return 0
                   ghc-pkg describe "$@";;

mods | pkgmods | modules | package-modules )
                   HELP "package-modules ATTR" "List ATTR's exposed modules" || return 0
                   ghc-pkg field "$1" "exposed-modules";;

phases | build-phases)
                   HELP "phases ATTR"          "Print ATTR's build phases" || return 0
                   echo $prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase $preDistPhases distPhase $postPhases
                   ;;

#+end_src
*** Miscellanea
  #+begin_src sh :var title=(org-tangle-item)
section-miscellanea )
section "${title}" eval loop-hunter progress watch ghc prefetch-ghc;;

eval | x )         HELP "eval BASH-EXPR"       "Passthrough, to execute anything defined." || return 0
                   "$@";;

loop-hunter )      HELP "loop-hunter"          "Detect attribute loops:  nix-shell 2>&1 | nh loop-hunter" || return 0
                   loop_hunter;;

p | progress )     HELP "progress"             "Live summary of new, complete and failing builds" || return 0
                   if    test -f "$(cat ${PKGDB}/current.build    2>/dev/null)"
                   then local log=$(cat ${PKGDB}/current.build    2>/dev/null)
                   else fail "Nothing to watch, exiting."
                   fi
                   echo "watching ${log}"
                   local nlines=$(stty size | awk '{print $1}')
                   watch --interval=1 --no-title bash -c "'cat $(cat ${PKGDB}/current.build    2>/dev/null) | nh x log_filter_progress' | tail -n$((nlines-1))";;

w | watch )        HELP "watch"                "Observe the current build, as it hits the logs.." || return 0
                   if    test -f "$(cat ${PKGDB}/current.build    2>/dev/null)"
                   then local log=$(cat ${PKGDB}/current.build    2>/dev/null)
                   else fail "Nothing to watch, exiting."
                   fi
                   echo "watching $log"
                   tail -f "$log";;

ghc )              HELP "ghc"                    "Shell with current GHC" || return 0
                   nix-shell -p haskell.compiler.ghc${GHC};;

pghc | prefetch-ghc )
                   HELP "prefetch-ghc GITREV"    "Prefetch a GHC revision" || return 0
                   local rev="$1"; shift
                   nix-prefetch-git git://git.haskell.org/ghc.git --fetch-submodules --rev ${rev};;

www )              # HELP "www URL-KIND ATTR"     "Elinks -> an URL associated with ATTR" || return 0
                   local kind="$1" name="$2";
                   elinks "$(url $kind $name)"
                   ;;

 * )		   fail "unknown command '${command}'";;
esac
}

echo "nh $*" >> ~/.nh_history
command_dispatch "$@"
  #+end_src

  ;;; Local Variables:
  ;;; eval: (progn (add-hook 'after-save-hook 'org-babel-tangle) (defun org-tangle-item () (cdr (assoc "ITEM" (org-entry-properties last-heading-pos)))) (defun org-babel-expand-body-simple-loop (acc rest) (if rest (let ((subst-pat (concat "${" (symbol-name (caar rest)) "}"))) (org-babel-expand-body-simple-loop (replace-regexp-in-string subst-pat (cdar rest) acc) (cdr rest))) acc)) (defun org-babel-expand-body:sh (body params) (let ((vars (org-babel--get-vars params))) (org-babel-expand-body-simple-loop body vars))))
  ;;; End:
