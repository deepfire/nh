* nh: manage Nix Haskell override sets
*** What

    [[https://travis-ci.org/deepfire/corr/][https://api.travis-ci.org/deepfire/nh.svg?branch=master]]

    Manage a set of Nix [[https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/configuration-ghc-8.4.x.nix][Haskell package overrides]], somewhat automatically.

    Put another way, it aids definition and validation of properties of every override in a set:
      - validity (/whether it breaks things/)
      - necessity (/whether it's needed to keep things working, along with a proof/)
      - actuality (/whether the override status is up to date with the upstream, Hackage and Nixpkgs/)

    Definitions are managed somewhat conveniently, like:

    : nh hackage    foo 1.2.14
    : nh hackage-up foo
    : nh unmerged   bar concerned-citizen PR-number

*** Brutal, no-nonsense introduction

    1. Init a package DB:

       : nh init

       ..which will ask you to create a config file first -- follow the
       instuctions.

    2. Add overrides:

       : nh hackage-up lens                            # easy: there's a Hackage release, get the latest

       : nh set-upstream microlens-th aelve
       : nh upstream     microlens-th master           # Fetch the tip of upstream's master
       : nh set-repoName microlens-th microlens        # A single repository carries several packages.
       : nh chdir        microlens-th microlens-th

       : nh set-upstream hedgehog hedgehogqa
       : nh unmerged     hedgehog gwils 134 [GIT-REV]  # the third argument to =unmerged= is the Github PR #

    3. Observe the changes:

       : nh show lens
       : nh show microlens-th
       : nh show hedgehog

       ..and you always can generate =overrides.nix= from the very latest package
       database -- although it happens transparently most of the time:

       : nh overrides

    4. Validate if the overridden packages build now:

       : nh baseline [NAME..]                          # Defaults to building everything

    5. See what the audit tool thinks about the situation:

       : nh audit --skip-baseline [NAME..]             # Defaults to everything, once more
                                                       # --skip-baseline, because we already did that part.

       It should complain, at the very least because the =trim= part was not run,
       and so there's no proof that any of the overrides are necessary.

       Note that the =nt audit= subcommand provides suggestions, that can be
       auto-executed when the =--auto-fix= option is supplied.

    6. Let's try trimming the set:

       : nh trim --skip-baseline [NAME..]

       That would take a while, and also it won't do anything to the recorded
       overrides -- it merely collected information, as an intermediate step.

       Let's execute on that information, then:

       : nh execute-trim

    7. Audit again:

       : nh audit

       ..and this is probably going to fail, because the trim is often over-eager.
       So, some of the overrides need to be reintroduced, and the
       figuring-out-what-and-why part is manual (albeit assisted).  Thankfully, we
       can record the manually-collected information in the database (which would
       prevent trimming of this override in the future):

       : nh set-explanation broken-attribute doCheck

       Rinse, repeat -- and remember that individual attributes can be rebuilt
       using =nh baseline=.

       Also, explanations (aka proofs of override) can be shown per-override with:

       : nh explain happy src

    Finally:  look at =suite.sh= for inspiration.

*** Overview: lifecycle of fixes

    First, we describe the general flow of fixes, to establish a terminology.

    1. Fixes are generally born on a third-party Github repo, and they are
       expected to be submitted upstream via pull request.
    2. The PR gets merged upstream.
    3. Upstream cuts a release, bumping the package version in the cabal file.
    4. Upstream performs a Hackage upload.
    5. Nixpkgs imports Hackage, adding a versioned =package-attribute_1_2_1_0=.
    6. Nixpkgs promotest the versioned =package-attribute_1_2_1_0= to
       =package-attribute=, which completes the cycle.

    7. Nixpkgs also supports non-source tweaks (jailbreaking out of restrictive
       version bounds, test and Haddock generation disables).

*** Overview: above lifecycle, seen by =nh=

    =nh= maps the above into a /status/, per attribute:

    - unmerged :: phases #1
    - upstreamed :: phases #2 and #3
    - hackaged :: phase #4
    - shadowed :: phase #5 (/after shadow attributes -- those shadowing non-versioned ones/)
    - config :: not-really-phase #7

*** Key points

    1. =nh= tracks the aforementioned attribute status and content of the
       attribute overrides in a /package database/ (aka *PKGDB*).  This is just a
       file-system directory -- but it's better to version it in Git, to be able
       to recover, when =nh= goes off-rails and breaks overrides.

    2. The result is delivered in the form of a Nix file defining a GHC package
       set override (customarily called =overrides.nix=).

       This trivially-structured, generated file is then supposed to be imported
       into another, static Nix file called =packages.nix=, which then forms a
       proper GHC package set.  That one can be passed to =nix-build=.

    3. The major package DB operations that =nh= provides are:

       - baseline :: Build every attribute in the override set.
       - trim     :: Try to remove overrides, one by one, and record the results
                     of those attempts in the package DB -- trying to deducing
                     whether these overrides are necessary.  It is a heuristic.
       - execute-trim :: Modify the package DB in accordance with the /trim/ step.
                         This effectively removes any overrides that weren't found
                         necessary.  This is also error-prone (more things are
                         sometimes removed than is feasible).
       - audit    :: Verify every attribute against a set of status-dependent
                     invariants, that ensure:
         - the override necessity (along with the existence of proof), and
         - the override being up-to-date.

    4. =nh= keeps as much build information as possible, and that includes store
       derivation links, store source links, override expressions and build logs
       for every build attempt that takes place.  In particular every attribute
       build attempt happens in three phases, handled separately:
       - attribute instantiation
       - dependency pre-build
       - build of the attribute itself

* Appendix: Example workflow of importing existing overrides
#+BEGIN_SRC sh
$ nh x hackage funcmp 1.9
downloading ‘http://hackage.haskell.org/package/funcmp-1.9.tar.gz’... [0/0 KiB, 0.0 KiB/s]
path is ‘/nix/store/akhnn03wfi3jlx2rqgwjdz07qpz983iz-funcmp-1.9.tar.gz’
  - 1d5appkjhajb9ndv2gwnfz8lw2w53v8baajzmrhg26ihzj1bkch8
  - https://hackage.haskell.org/package/funcmp-1.9

$ nh set-explanation funcmp src
funcmp.def/meta.src.explanation: Needed for (<>) in prelude

$ nh jailbreak deepseq-generics

$ nh set-explanation deepseq-generics jailbreak
deepseq-generics.def/meta.jailbreak.explanation: https://github.com/haskell-hvr/deepseq-generics/pull/4

$ nh set-repoName securemem hs-securemem
$ nh set-upstream securemem vincenthz

$ nh unmerged securemem shlevy 12 6168d90b00bfc6a559d3b9160732343644ef60fb
- 06dhx1z44j5gshpdlsb4aryr3g4was3x4c2sgv1px8j57zrvlypx
- https://github.com/vincenthz/hs-securemem/commit/6168d90b00bfc6a559d3b9160732343644ef60fb
#+END_SRC
* Appendix: Structure of the package database

  - def :: definitions
    - meta :: non-override metadata
    - over :: overrides
    - hackage, github :: src-specific information, per-attribute-override
  - cache :: override cache, per-attribute
  - build :: build output information: logs, expressions, derivations

* Appendix: help

#+BEGIN_SRC
Usage:  nh [--cls] [--trace] [--debug] SUBCMD [SUBARGS..]

  General:

   ls [REGEX]                List all overridden attributes
   info ATTR                 Overview of an attribute's PKGDB
   overview                  List overridden attributes, grouped by status + relevant info

  Metadata manipulation:

   ls-meta ATTR              List attribute's metadata (as opposed to overrides
   meta ATTR META            Print a single metadata entry of an attribute
   set-meta ATTR META VAL    Set a single metadata entry of an attribute
   edit-meta ATTR META       Edit the current attribute's meta value using readline

  Override manipulation (low level):

   disable ATTR[.OVER]       Disable all/single overrides for an attribute
   enable ATTR[.OVER]        Re-enable previously disabled overrides
   set-explanation ATTR OVER Provide a manual explanation for an override's existence
   set-erdeps ATTR 'ATTR..'  Set attribute's essential rev-deps that must keep working
   ls-over ATTR              List attribute's overrides
   get ATTR OVER             Get an attribute's override value
   set ATTR OVER VAL         Set an attribute's override value;  "" removes the override
   edit ATTR OVER            Edit the current attribute's value using readline
   edit ATTR OVER            Edit the current attribute's value using readline
   check ATTR                Disable an existing dontCheck override
   dontCheck ATTR            Disable tests
   haddock ATTR              Disable an existing dontHaddock override
   dontHaddock ATTR          Disable Haddock generation
   jailbreak ATTR            Turn on jailbreaking
   dontJailbreak ATTR        Disable an existing jailbreak override
   chdir ATTR SUBDIR         Change directory before build;  "" removes the override
   extraLibs ATTR '[ .. ]'   Specify extra dependencies;  "" removes the override

  Attribute status classification:

   status ATTR               Print status of a single attribute
   ls-shadowed               List all attributes with status 'shadowed'
   ls-hackaged                                            ...'hackaged'
   ls-upstreamed                                          ...'upstreamed'
   ls-unmerged                                            ...'unmerged'
   ls-config                                              ...'config'

  Override manipulation (high-level):

   hackage ATTR [RELEASE=upstream-latest]
                             Set the source override to a Hackage release
   unmerged ATTR USER PR# [REV=HEAD]
                             Set the source override to a 3rd-party Github commit
   upstream ATTR [REV=HEAD]  Set the source override to an upstream Github commit

  Github-based (unmerged/upstream) override manipulation:

   github-up ATTR            Bump a Github override to its latest HEAD
   set-pr ATTR PR#           Set the PR# of an attribute's Github override
   set-upstream ATTR GITHUB-USER
                             Specify an attribute's Github upstream username
   set-repoName ATTR REPO    Set an attribute's Github repository name

  Build & results:

   build [COMMON-OPTS] ATTR  Build a single attribute
   log ATTR [OVER=baseline]  Obtain trim build logs for a single override
   failure ATTR [OVER=baseline]
                             Obtain trim failure kind of an override
   failure-type ATTR [OVER=baseline]
                             Obtain trim failure type of an override
   failure-log ATTR [OVER=baseline]
                             Obtain trim failure log of an override
   expression ATTR [OVER=baseline]
                             See the the expression defining an override's trim
   proof ATTR OVER           Print the proof of necessity for an attribute's override

  Nix-level inferences:

   drv ATTR                  Store derivation for a single override
   src-drv ATTR              Store source derivation for a single override
   deps | refs | references ATTR
                             Store dependencies of an override
   rdeps | referrers ATTR    Store reverse dependencies of an override

  Override database maintenance:

   instantiate [--reuse-cache] [ATTR..]
                             Instantiate overridden attrs (or specified subset)
   acme [--reuse-cache]      Build everything at once, collecting all failures
   baseline [--reuse-{overrides,cache}] [ATTR..]
                             Build overridden attrs (or specified subset)
   trim [--skip-baseline] [--reuse-cache] [ATTR..]
                             Suggest a reduction to the override set (or specified subset)
   trim-single ATTR OVER     Attempt trimming a specific override of a given attribute
   show-trims                Show the trim suggestion
   execute-trims             Execute the suggestion
   audit [--autofix] [--autoonly] [--skip-baseline] [--reuse-{overrides,cache}] [ATTR]
                             Sanity check the overridden attrs (or specified subset).  --autofix applies suggestions

  Generation of overrides:

   over | override | show-override ATTR
                             Print the attribute's override defined by PKGDB
   overrides [--reuse-cache] Generate overrides.nix
   overrides-descs           As overrides, but mandate that every override comes with a proof
   cache [--require-descs]   Regenerate override cache
   show-cache ATTR           Print the cached text of attribute's override (DEBUG)

  Miscellanea:

   eval 'BASH-EXPR'          Passthrough, to execute anything defined.
   shell                     Nix shell with up-to-date overrides (shell.nix required)
   cabal2shell               Nix shell from a cabal file (nothing else required)
   loop-hunter               Detect attribute loops:  nix-shell 2>&1 | nh loop-hunter
   progress                  Observe build progress
   watch                     Observe the current build, as it hits the logs..

#+END_SRC
